---
bg: 'Gon.png'
layout: post
title:  "golang基本类型"
crawlertitle: "golang"
summary: ""
date:   2019-12-02 12:00:00 +0800
categories: posts
tags: 'golang'
author: 宋天
---

golang基本类型， number, string, unicode, utf-8的基础知识




# 四种类型
- 基本类型，numbers, strings, booleans
- 聚合类型，arrays, structs
- 引用类型，pointers, slices, maps, functions, channels
- 接口类型，interface


# Integer
int8, int16, int32, int64

uint8, uint16, uint32, uint64

不同尺寸和有无符号的int

- int和uint, 具体大小取决于编译器
- rune, int32的同义词，很方便表示一个Unicode码点
- byte, int8的同义词，重点强调是一系列的原生数据而不是一个值
- uintptr, 大小不确定，但足以装下指针的值，通常用于底层编码，例如Go使用C库
- int和它们的兄弟不是一种类型，需要显示转换，尽管int的底层是32位和int32一致。
- 数学运算符，逻辑操作符，比较操作符, 位操作符，这些和其他语言的基本相同，下面是特殊的几个
    1. %, 取余操作符， 结果的符合和被除数一致， -5%3和-5%-3的结果都是-2
    2. &^, 位清除操作， z = x &^ y   当y位1时，z位位0，否则和x的一样, 顾名思义，根据y中为1的位去清除x中的位
- 左移时空位填0，右移时空位填符号位，5右移1位是2，所以负数右移时要谨慎，-5右移1位是-3，计算机底层使用补码来存，负数的补码是对应正数的二进制按位取反再加1，正数的补码是正数的二进制

> 小知识点： &位操作可以用来检测某个位是不是1, 5 & 1 大于 0 能看出5的最右一位是1，可以通过右移5或者左移1来探测5的二进制里面有多少个1

- 整型字面量可以是任何长度和类型的，（字面量的意思就是`a=5`,里面的5就是字面量）0开头的是八进制，0x开头的是十六进制，八进制多用于文件权限,十六进制多强调数字的位而不是值
- 使用fmt.Printf的%d,%o,%x来输出十进制，八进制和十六进制
- rune字面量是被单引号包起来的单个字符，可以写入ascii码`a`，也可以写入任意unicode码点例如`国`, 类型是int32, 可以使用fmt.Printf的%d,%c,%q来输出十进制，字符，和引号引起来的字符

# 浮点数Floating-Point Numbers

- float32和float64, float32提供大约6位小数精度，float64提供大约15位小数精度
- 特别大的数或者特别小的数应该用科学计数法
- 特殊数值0,-0,+Inf,-Inf,NaN, 任何和NaN的比较都是false

# 复数

- complex64和complex128,
- complex函数构建复数，real和imag函数去复数的实数和虚数
- 一个浮点字面量跟一个i就变成一个虚数字面量，例如3i,是实数为0的复数

# 布尔值

- true和false
- !，&&， ||， &&的优先级高于||, !是单元操作符
- 逻辑布尔表达式具有短路的表现，当前面的表达式足以确定真假的时候，就不在执行后面的表达式


# 字符串

字符串是不可变的一序列字节，可以包含任意数据，甚至0个字节，通常包含人类可读的文本，这些文本被解析为Utf8编码的码点（rune)

- len方法返回字符串字节的个数，而不是rune，可以通过索引访问指定位置的字节
- substring操作，s[i:j]返回新字符串包含i到j(不含j)的字节，长度为j-i, i和j都可以省略，从0或者到结尾，和python的切片类似。
- +操作将两个字符串进行拼接返回一个新字符串
- 可以使用==或者<进行比较，将一个字节一个字节进行比较
- **字符串的不可变性，保证了字符串的拷贝共享一份内存是安全的，所以拷贝任意长度的字符串和获取子串都是廉价的操作，它们共享着相同的内存，不会重新分配内存**

## 字符串字面量
- go源文件被uft8编码，所以可以在文件中直接写unicode字符
- 使用\来进行转义
- ``包裹的是原生字符串字面量，其中的内容不会被转义，适合写正则，html，json等字符串



## Unicode

- Unicode是一个收集世界上数中语言和符合的编码表，正如ASCII一样，将字符和数字进行对应起来，计算机存储数字，在需要展示给人的时候转换为字符
- Unicode的每个符号对应的数字的值称为Unicode码点(Unicode code point), 在Go里面就是rune
- Unicode中如果用rune（int32)来存储的话，是非常简单和正规的，这样所有字符的长度都占4个字节，然而，我们平常大多使用的字符还是2个字节就能表示的了，或者1个字节能表示的了（比如ASCII)，所有字符占4个字节会浪费很多空间，所以就出现了UTF-8编码

## UTF-8

UTF-8是一个将Unicode码点转换为不同长度的编码，它使用1到4个字节来存储一个字符，那么这我曾经想过的一个问题是，既然一个字符的长度不同，那么在一个字节序列里面，它是如何判断边界的呢，它怎么判断这两个字节是这个字符，而这一个字节是这个字符？utf-8是这么做的，它用字节里面的高位（high-order bit)来标识下面跟着多少个字节，比如0xxxxx这样的代表着是ASCII码，下一个字节将是一个新的字符。110xxxx代表后面还跟随着两个字节，后面跟随的两个字节都是以10开头的。这样就能使用utf-8编码来节省空间。

- utf8有很多特性，使我们不用对它转为unicode也能进行获取子串，比较，从左到右读取，不必担心上下文。

| Unicode       | Utf-8                               |
| ------------- | ----------------------------------- |
| 000000-00007F | 0xxxxxxx                            |
| 000080-0007FF | 110xxxxx 10xxxxxx                   |
| 000800-00FFFF | 1110xxxx 10xxxxxx 10xxxxxx          |
| 010000-10FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

- 许多unicode不容易写，所以go允许我们直接写数值码点，下面都是6个字节的字面量(看utf8很容易看出是6个字节，十六进制两个数是一个字节)

```
"世界"
"\xe4\xb8\x96\xe7\x95\x8c"   utf8
"\u4e16\u754c"               16 bit unicode
"\U00004e16\U0000754c"       32 bit unicode
```
- 下面都是rune字面量，256内的值可以用单个十六进制来表示，`\xe4\xb8\x96`虽然是一个utf8编码的码点，但不是一个有效的rune字面量
```
'世', '\u4e16', '\U00004e16'
'\x41'

'\xe4\xb8\x96' // 不是rune字面量
```

- 对于字符串直接使用索引遍历，遍历的是字节，而可用使用range来遍历rune, utf8.RuneCountInString可以返回某个字节rune的个数
- 当utf8在解码时碰到错误的字节会使用`\uFFFD`来代替，是一个�这样的符号，当碰到了这样的符号，说明其他系统传过来的字节编码可能是不清楚的
- rune和string相互转化
```
s:="哈哈"
r:=[]rune(s)   // string => rune utf8 decode
string(r)      // rune => string utf8 encode
string(65)     // "A"  integer => string
string(0x4eac) // "京"  0x4eac也是integer字面量
string(1234567)// � 无效
```

## 字符和字节切片

- 四个重要的标准包
    1. strings,对字符串基本的查找，替换，比较，去空，分割，结合操作
    2. bytes，对[]byte有相同的操作
    3. strconv，负责boolean, int, float等类型转换到string
    4. unicode, 对rune的各种操作
- 因为string是不可变的，所以当想通过不断累积的方式获取新的string需要不停的分配内存，使用bytes.Buffer效率更好
- 下面的方式可以将string和[]byte互转，在转化的过程中，重新分配内存和拷贝是必要的，因为[]byte是可以改变的
```
s := "abc"
b := []byte(s)
s2 := string(b)

```

## 数字和字符串转换

- 两种将数字转换为字符串的方式，fmt.Sprintf和strconv.Itoa
- strconv.FormatInt可以将数字转换为不同的进制，fmt.Sprintf的%b, %d, %u, %x也可以将数字转换为特定的进制，而且还可以加入一些额外的信息
- strconv.Atoi和strconv.ParseInt可以将字符串的数字转换为数字，ParseInt可以指定进制和返回的尺寸


# 常量

- 在编译时期就能确定的值
- 常量的类型既可以显示声明，也可以根据值来进行推断
- iota, 常量生成器，在常量变量自动生成自动增长的值，声明一些规律的常量很好用，比如周一到周日，KiB,MiB,GiB这些单位。iota依赖左移和右移运算符来完成某些操作，所以对于KB,MB这些值是1000的是无法用iota声明的（KiB和KB的区别，一个是1024,一个是1000，但之前学习的时候KB指的是1024， 默认KB是KiB)


## 无类型常量

- 常量是可以无类型的，无类型意思就是类型在用的时候才显式或者隐式转换，比如0这个常量，赋值给int，它就是int类型，赋值给float64, 它就是float64类型
- 六种无类型常量，无类型布尔，无类型整形，无类型rune, 无类型float, 无类型复数，无类型字符串