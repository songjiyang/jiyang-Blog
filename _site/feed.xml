<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JiYang's Blog</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 03 Dec 2019 12:03:00 +0800</pubDate>
    <lastBuildDate>Tue, 03 Dec 2019 12:03:00 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>5.1.1版本elasticsearch中英文排序</title>
        <description>&lt;p&gt;5.1.1版本elasticsearch中英文排序问题排查及解决&lt;/p&gt;

&lt;h1 id=&quot;环境&quot;&gt;环境&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;elasticsearch：5.1.1&lt;/li&gt;
  &lt;li&gt;分词插件mmseg: 5.1.1&lt;/li&gt;
  &lt;li&gt;拼音插件pinyin: 5.1.1&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;配置&quot;&gt;配置&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;analyzer&quot;: {
          &quot;pinyin_raw&quot;: {
            &quot;type&quot;: &quot;pinyin&quot;,
            &quot;keep_first_letter&quot;: false,
            &quot;keep_full_pinyin&quot;: false,
            &quot;keep_joined_full_pinyin&quot;: true,
            &quot;keep_none_chinese_in_joined_full_pinyin&quot;: true,
            &quot;keep_none_chinese_in_first_letter&quot;: true,
            &quot;none_chinese_pinyin_tokenize&quot;: false,
            &quot;lowercase&quot;: true
          }
          ...

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;需求&quot;&gt;需求&lt;/h1&gt;
&lt;p&gt;想对文件名进行按照字典顺序排序，文件名有中文和英文，中文使用pinyin插件转化为拼音&lt;/p&gt;

&lt;h1 id=&quot;问题&quot;&gt;问题&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;纯英文或纯数字混合分词结果多一个空格&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; http://ec2-52-81-100-48.cn-north-1.compute.amazonaws.com.cn:9200/test_new/_analyze?text=36kr&amp;amp;analyzer=pinyin_raw
 
 
 {
    &quot;tokens&quot;: [
        {
            &quot;token&quot;: &quot;36kr&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 3,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 0
        },
        {
            &quot;token&quot;: &quot;&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 0,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 1
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;英文和中文混合时，不能正确拼接在一起, 且英文总是排在最前面&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://ec2-52-81-100-48.cn-north-1.compute.amazonaws.com.cn:9200/test_new/_analyze?text=哈哈dc&amp;amp;analyzer=pinyin_raw

{
    &quot;tokens&quot;: [
        {
            &quot;token&quot;: &quot;dc&quot;,
            &quot;start_offset&quot;: 1,
            &quot;end_offset&quot;: 3,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 0
        },
        {
            &quot;token&quot;: &quot;haha&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 4,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 1
        }
    ]
}

本来应该是hahadc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;解决过程&quot;&gt;解决过程&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;问题1之前pinyin插件的issue里面有人提到过，增加一个空白过滤器就可以去掉这个空白字符 &lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-pinyin/issues/163&quot;&gt;issue&lt;/a&gt;, 我自己也尝试过有效，但这个过滤器可以不加，升级es可以解决，所以下面测试的配置还是上面的配置。&lt;/li&gt;
  &lt;li&gt;问题2查看pinyin插件的配置文档看到keep_none_chinese_in_joined_full_pinyin这个配置会将非中文和英文连接起来，但结果却没有，经过排查，发现pinyin插件5.1.1是不支持这个参数，由5.2.0的relase的commit可以看出是在这个版本才支持keep_none_chinese_in_joined_full_pinyin &lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-pinyin/compare/v5.2.0...master&quot;&gt;pinyin插件5.2.0commit记录&lt;/a&gt;, 并且解决了&lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-pinyin/issues/80&quot;&gt;#80issue&lt;/a&gt;, 在这个issue里面同时出现了上述两个问题，拼音插件的作者回复下载5.2.2可以解决上述问题&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以最终打算下载es5.2.2，并按照mmseg和pinyin5.2.2&lt;/p&gt;

&lt;h1 id=&quot;测试522分词&quot;&gt;测试5.2.2分词&lt;/h1&gt;

&lt;p&gt;在相同配置的情况下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://52.82.10.41:9200/test_new/_analyze?analyzer=pinyin_raw&amp;amp;text=36kr

{
    &quot;tokens&quot;: [
        {
            &quot;token&quot;: &quot;36kr&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 4,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 0
        }
    ]
}



http://52.82.10.41:9200/test_new/_analyze?analyzer=pinyin_raw&amp;amp;text=哈哈dc
{
    &quot;tokens&quot;: [
        {
            &quot;token&quot;: &quot;hahadc&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 6,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 0
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;已经解决了上述问题并且满足了我们的需要&lt;/p&gt;

&lt;h1 id=&quot;结论&quot;&gt;结论&lt;/h1&gt;

&lt;p&gt;分词出现空白和中英文连接不生效的情况是elasticsearch和插件版本较低导致， 我们的最终解决方式是升级elasticsearch和插件到5.2.2， 因为升级es可以会对应用整体造成影响，升级之前需要先评估应用对es的依赖性。&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Dec 2019 12:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/chinese_sort/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/chinese_sort/</guid>
        
        <category>elasticsearch</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>golang基本类型</title>
        <description>&lt;p&gt;golang基本类型， number, string, unicode, utf-8的基础知识&lt;/p&gt;

&lt;h1 id=&quot;四种类型&quot;&gt;四种类型&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;基本类型，numbers, strings, booleans&lt;/li&gt;
  &lt;li&gt;聚合类型，arrays, structs&lt;/li&gt;
  &lt;li&gt;引用类型，pointers, slices, maps, functions, channels&lt;/li&gt;
  &lt;li&gt;接口类型，interface&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;integer&quot;&gt;Integer&lt;/h1&gt;
&lt;p&gt;int8, int16, int32, int64&lt;/p&gt;

&lt;p&gt;uint8, uint16, uint32, uint64&lt;/p&gt;

&lt;p&gt;不同尺寸和有无符号的int&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;int和uint, 具体大小取决于编译器&lt;/li&gt;
  &lt;li&gt;rune, int32的同义词，很方便表示一个Unicode码点&lt;/li&gt;
  &lt;li&gt;byte, int8的同义词，重点强调是一系列的原生数据而不是一个值&lt;/li&gt;
  &lt;li&gt;uintptr, 大小不确定，但足以装下指针的值，通常用于底层编码，例如Go使用C库&lt;/li&gt;
  &lt;li&gt;int和它们的兄弟不是一种类型，需要显示转换，尽管int的底层是32位和int32一致。&lt;/li&gt;
  &lt;li&gt;数学运算符，逻辑操作符，比较操作符, 位操作符，这些和其他语言的基本相同，下面是特殊的几个
    &lt;ol&gt;
      &lt;li&gt;%, 取余操作符， 结果的符合和被除数一致， -5%3和-5%-3的结果都是-2&lt;/li&gt;
      &lt;li&gt;&amp;amp;^, 位清除操作， z = x &amp;amp;^ y   当y位1时，z位位0，否则和x的一样, 顾名思义，根据y中为1的位去清除x中的位&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;左移时空位填0，右移时空位填符号位，5右移1位是2，所以负数右移时要谨慎，-5右移1位是-3，计算机底层使用补码来存，负数的补码是对应正数的二进制按位取反再加1，正数的补码是正数的二进制&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;小知识点： &amp;amp;位操作可以用来检测某个位是不是1, 5 &amp;amp; 1 大于 0 能看出5的最右一位是1，可以通过右移5或者左移1来探测5的二进制里面有多少个1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;整型字面量可以是任何长度和类型的，（字面量的意思就是&lt;code class=&quot;highlighter-rouge&quot;&gt;a=5&lt;/code&gt;,里面的5就是字面量）0开头的是八进制，0x开头的是十六进制，八进制多用于文件权限,十六进制多强调数字的位而不是值&lt;/li&gt;
  &lt;li&gt;使用fmt.Printf的%d,%o,%x来输出十进制，八进制和十六进制&lt;/li&gt;
  &lt;li&gt;rune字面量是被单引号包起来的单个字符，可以写入ascii码&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;，也可以写入任意unicode码点例如&lt;code class=&quot;highlighter-rouge&quot;&gt;国&lt;/code&gt;, 类型是int32, 可以使用fmt.Printf的%d,%c,%q来输出十进制，字符，和引号引起来的字符&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;浮点数floating-point-numbers&quot;&gt;浮点数Floating-Point Numbers&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;float32和float64, float32提供大约6位小数精度，float64提供大约15位小数精度&lt;/li&gt;
  &lt;li&gt;特别大的数或者特别小的数应该用科学计数法&lt;/li&gt;
  &lt;li&gt;特殊数值0,-0,+Inf,-Inf,NaN, 任何和NaN的比较都是false&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;复数&quot;&gt;复数&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;complex64和complex128,&lt;/li&gt;
  &lt;li&gt;complex函数构建复数，real和imag函数去复数的实数和虚数&lt;/li&gt;
  &lt;li&gt;一个浮点字面量跟一个i就变成一个虚数字面量，例如3i,是实数为0的复数&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;布尔值&quot;&gt;布尔值&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;true和false&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;!，&amp;amp;&amp;amp;，&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;， &amp;amp;&amp;amp;的优先级高于&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;, !是单元操作符&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;逻辑布尔表达式具有短路的表现，当前面的表达式足以确定真假的时候，就不在执行后面的表达式&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;字符串&quot;&gt;字符串&lt;/h1&gt;

&lt;p&gt;字符串是不可变的一序列字节，可以包含任意数据，甚至0个字节，通常包含人类可读的文本，这些文本被解析为Utf8编码的码点（rune)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;len方法返回字符串字节的个数，而不是rune，可以通过索引访问指定位置的字节&lt;/li&gt;
  &lt;li&gt;substring操作，s[i:j]返回新字符串包含i到j(不含j)的字节，长度为j-i, i和j都可以省略，从0或者到结尾，和python的切片类似。&lt;/li&gt;
  &lt;li&gt;+操作将两个字符串进行拼接返回一个新字符串&lt;/li&gt;
  &lt;li&gt;可以使用==或者&amp;lt;进行比较，将一个字节一个字节进行比较&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;字符串的不可变性，保证了字符串的拷贝共享一份内存是安全的，所以拷贝任意长度的字符串和获取子串都是廉价的操作，它们共享着相同的内存，不会重新分配内存&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;字符串字面量&quot;&gt;字符串字面量&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;go源文件被uft8编码，所以可以在文件中直接写unicode字符&lt;/li&gt;
  &lt;li&gt;使用\来进行转义&lt;/li&gt;
  &lt;li&gt;``包裹的是原生字符串字面量，其中的内容不会被转义，适合写正则，html，json等字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unicode&quot;&gt;Unicode&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Unicode是一个收集世界上数中语言和符合的编码表，正如ASCII一样，将字符和数字进行对应起来，计算机存储数字，在需要展示给人的时候转换为字符&lt;/li&gt;
  &lt;li&gt;Unicode的每个符号对应的数字的值称为Unicode码点(Unicode code point), 在Go里面就是rune&lt;/li&gt;
  &lt;li&gt;Unicode中如果用rune（int32)来存储的话，是非常简单和正规的，这样所有字符的长度都占4个字节，然而，我们平常大多使用的字符还是2个字节就能表示的了，或者1个字节能表示的了（比如ASCII)，所有字符占4个字节会浪费很多空间，所以就出现了UTF-8编码&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;utf-8&quot;&gt;UTF-8&lt;/h2&gt;

&lt;p&gt;UTF-8是一个将Unicode码点转换为不同长度的编码，它使用1到4个字节来存储一个字符，那么这我曾经想过的一个问题是，既然一个字符的长度不同，那么在一个字节序列里面，它是如何判断边界的呢，它怎么判断这两个字节是这个字符，而这一个字节是这个字符？utf-8是这么做的，它用字节里面的高位（high-order bit)来标识下面跟着多少个字节，比如0xxxxx这样的代表着是ASCII码，下一个字节将是一个新的字符。110xxxx代表后面还跟随着两个字节，后面跟随的两个字节都是以10开头的。这样就能使用utf-8编码来节省空间。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;utf8有很多特性，使我们不用对它转为unicode也能进行获取子串，比较，从左到右读取，不必担心上下文。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Unicode&lt;/th&gt;
      &lt;th&gt;Utf-8&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;000000-00007F&lt;/td&gt;
      &lt;td&gt;0xxxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;000080-0007FF&lt;/td&gt;
      &lt;td&gt;110xxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;000800-00FFFF&lt;/td&gt;
      &lt;td&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;010000-10FFFF&lt;/td&gt;
      &lt;td&gt;11110xxx 10xxxxxx 10xxxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;许多unicode不容易写，所以go允许我们直接写数值码点，下面都是6个字节的字面量(看utf8很容易看出是6个字节，十六进制两个数是一个字节)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;世界&quot;
&quot;\xe4\xb8\x96\xe7\x95\x8c&quot;   utf8
&quot;\u4e16\u754c&quot;               16 bit unicode
&quot;\U00004e16\U0000754c&quot;       32 bit unicode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;下面都是rune字面量，256内的值可以用单个十六进制来表示，&lt;code class=&quot;highlighter-rouge&quot;&gt;\xe4\xb8\x96&lt;/code&gt;虽然是一个utf8编码的码点，但不是一个有效的rune字面量&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'世', '\u4e16', '\U00004e16'
'\x41'

'\xe4\xb8\x96' // 不是rune字面量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;对于字符串直接使用索引遍历，遍历的是字节，而可用使用range来遍历rune, utf8.RuneCountInString可以返回某个字节rune的个数&lt;/li&gt;
  &lt;li&gt;当utf8在解码时碰到错误的字节会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;\uFFFD&lt;/code&gt;来代替，是一个�这样的符号，当碰到了这样的符号，说明其他系统传过来的字节编码可能是不清楚的&lt;/li&gt;
  &lt;li&gt;rune和string相互转化&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s:=&quot;哈哈&quot;
r:=[]rune(s)   // string =&amp;gt; rune utf8 decode
string(r)      // rune =&amp;gt; string utf8 encode
string(65)     // &quot;A&quot;  integer =&amp;gt; string
string(0x4eac) // &quot;京&quot;  0x4eac也是integer字面量
string(1234567)// � 无效
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;字符和字节切片&quot;&gt;字符和字节切片&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;四个重要的标准包
    &lt;ol&gt;
      &lt;li&gt;strings,对字符串基本的查找，替换，比较，去空，分割，结合操作&lt;/li&gt;
      &lt;li&gt;bytes，对[]byte有相同的操作&lt;/li&gt;
      &lt;li&gt;strconv，负责boolean, int, float等类型转换到string&lt;/li&gt;
      &lt;li&gt;unicode, 对rune的各种操作&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;因为string是不可变的，所以当想通过不断累积的方式获取新的string需要不停的分配内存，使用bytes.Buffer效率更好&lt;/li&gt;
  &lt;li&gt;下面的方式可以将string和[]byte互转，在转化的过程中，重新分配内存和拷贝是必要的，因为[]byte是可以改变的&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s := &quot;abc&quot;
b := []byte(s)
s2 := string(b)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;数字和字符串转换&quot;&gt;数字和字符串转换&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;两种将数字转换为字符串的方式，fmt.Sprintf和strconv.Itoa&lt;/li&gt;
  &lt;li&gt;strconv.FormatInt可以将数字转换为不同的进制，fmt.Sprintf的%b, %d, %u, %x也可以将数字转换为特定的进制，而且还可以加入一些额外的信息&lt;/li&gt;
  &lt;li&gt;strconv.Atoi和strconv.ParseInt可以将字符串的数字转换为数字，ParseInt可以指定进制和返回的尺寸&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;常量&quot;&gt;常量&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;在编译时期就能确定的值&lt;/li&gt;
  &lt;li&gt;常量的类型既可以显示声明，也可以根据值来进行推断&lt;/li&gt;
  &lt;li&gt;iota, 常量生成器，在常量变量自动生成自动增长的值，声明一些规律的常量很好用，比如周一到周日，KiB,MiB,GiB这些单位。iota依赖左移和右移运算符来完成某些操作，所以对于KB,MB这些值是1000的是无法用iota声明的（KiB和KB的区别，一个是1024,一个是1000，但之前学习的时候KB指的是1024， 默认KB是KiB)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;无类型常量&quot;&gt;无类型常量&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;常量是可以无类型的，无类型意思就是类型在用的时候才显式或者隐式转换，比如0这个常量，赋值给int，它就是int类型，赋值给float64, 它就是float64类型&lt;/li&gt;
  &lt;li&gt;六种无类型常量，无类型布尔，无类型整形，无类型rune, 无类型float, 无类型复数，无类型字符串&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Dec 2019 12:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/basic_type/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/basic_type/</guid>
        
        <category>golang</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>mongodb工具，安全，故障</title>
        <description>&lt;p&gt;mongodb导入和导入工具，监控工具，授权认证，故障排除&lt;/p&gt;

&lt;h3 id=&quot;安全&quot;&gt;安全&lt;/h3&gt;

&lt;h4 id=&quot;用户&quot;&gt;用户&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;创建第一个用户&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; db.createUser(
... {
... user: &quot;myUserAdmin&quot;,
... pwd: &quot;passwd&quot;,
... roles: [ &quot;userAdminAnyDatabase&quot;]
... }
... )
Successfully added user: { &quot;user&quot; : &quot;myUserAdmin&quot;, &quot;roles&quot; : [ &quot;userAdminAnyDatabase&quot; ] }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;认证&quot;&gt;认证&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在mongod启动时加入–auth参数开启登录验证&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用用户名和密码进行身份验证&lt;/p&gt;

    &lt;p&gt;mongo -u “myUserAdmin” -p “passwd” –authenticationDatabase “admin”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;authenticationDatabase表示创建用户使用的数据库，但不是指定该用户权限的。&lt;/li&gt;
  &lt;li&gt;如果目的既是登陆test数据库，而用户也是test数据库中创建，那么可以不用写后面的参数 –authenticationDatabase&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;授权&quot;&gt;授权&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;权限 = 在哪里 + 做什么&lt;/p&gt;

    &lt;p&gt;{resource:{db:”test”, collections: “”}, actions:[“find”, “update”]}&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;角色，一组权限的集合
    &lt;ol&gt;
      &lt;li&gt;read, 读取当前数据库中所有非系统集合&lt;/li&gt;
      &lt;li&gt;readWrite, 读写当前数据库中所有非系统集合&lt;/li&gt;
      &lt;li&gt;dbAdmin, 管理当前数据库&lt;/li&gt;
      &lt;li&gt;userAdmin, 管理当前数据库中的用户和角色&lt;/li&gt;
      &lt;li&gt;read/readWrite/dbAdmin/userAdminAnyDatabase 对所有数据库执行操作（只在admin数据库提供）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;创建一个只能读取test数据库的用户&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use test;
db.createUser(
    {
        user: &quot;testReader&quot;,
        pwd: &quot;passwd&quot;,
        roles: [{role: &quot;read&quot;, db: &quot;test&quot;}]
    }
)

Successfully added user: {
	&quot;user&quot; : &quot;testReader&quot;,
	&quot;roles&quot; : [
		{
			&quot;role&quot; : &quot;read&quot;,
			&quot;db&quot; : &quot;test&quot;
		}
	]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;创建一个只能读取accounts集合的用户&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use test;
db.createRole(
    {
        role: &quot;readAccount&quot;,
        privileges: [
            {
                resource: {
                    db:&quot;test&quot;, 
                    collection: &quot;accounts&quot;
                },
                actions: [&quot;find&quot;]
            }
        ],
        roles: []
    }
)
use test;
db.createUser(
    {
        user: &quot;accountsReader&quot;,
        pwd: &quot;passwd&quot;,
        roles: [&quot;readAccount&quot;]
    }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;roles字段可以从已有角色中继承权限&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;工具&quot;&gt;工具&lt;/h2&gt;

&lt;h4 id=&quot;数据导入导出&quot;&gt;数据导入导出&lt;/h4&gt;
&lt;h5 id=&quot;mongoexport&quot;&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongoexport/&quot;&gt;mongoexport&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&quot;mongoimport&quot;&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongoimport/index.html&quot;&gt;mongoimport&lt;/a&gt;&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;upsertFileds 根据特定字段去对比从而选择去更新还是插入&lt;/li&gt;
  &lt;li&gt;stopOnError 发送错误停止&lt;/li&gt;
  &lt;li&gt;maintainInsertionOrder 维持csv的顺序导入&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;监控&quot;&gt;监控&lt;/h4&gt;

&lt;h5 id=&quot;mongostat统计mongodb数据库当前的状态&quot;&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongostat/index.html&quot;&gt;mongostat&lt;/a&gt;，统计mongodb数据库当前的状态&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;需要用户有clusterMonitor的角色&lt;/li&gt;
  &lt;li&gt;可以指定打印间隔和次数&lt;/li&gt;
  &lt;li&gt;o指定需要查看的指标
    &lt;ol&gt;
      &lt;li&gt;commman - 每秒执行的命令数&lt;/li&gt;
      &lt;li&gt;dirty, used - 数据库引擎缓存的使用量百分比&lt;/li&gt;
      &lt;li&gt;vsize - 虚拟内存使用量（MB)&lt;/li&gt;
      &lt;li&gt;res - 常驻内存使用量&lt;/li&gt;
      &lt;li&gt;conn - 连接数&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;mongotop显示每个集合上的读写时间&quot;&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongotop/index.html&quot;&gt;mongotop&lt;/a&gt;,显示每个集合上的读写时间&lt;/h5&gt;

&lt;h2 id=&quot;故障&quot;&gt;故障&lt;/h2&gt;

&lt;h5 id=&quot;响应时间过长&quot;&gt;响应时间过长&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;合适的索引，使用explain()查看索引的有效性&lt;/li&gt;
  &lt;li&gt;工作集超出RAM的大小，使用mongostat查看服务的状态，used百分比远远大过dirty的百分比时，表示mongo内存不够使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;连接失败&quot;&gt;连接失败&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;默认情况下，mongod进程可以支持多达65536个连接，不恰当的&lt;strong&gt;配置&lt;/strong&gt;可能限制连接数
    &lt;ol&gt;
      &lt;li&gt;db.serverStatus().connections可查看连接数&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;ulimt -a配置中间的open files也会限制mongodb的连接数&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Sep 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/mongodb_tool_security/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mongodb_tool_security/</guid>
        
        <category>mongodb</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>mongodb技巧</title>
        <description>&lt;p&gt;mongodb的一些技巧&lt;/p&gt;

&lt;h2 id=&quot;按日期分组&quot;&gt;按日期分组&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;要分组的日期是Date类型的&lt;/li&gt;
  &lt;li&gt;注意timezone, +0800代表中国时区&lt;/li&gt;
  &lt;li&gt;group的_id可以进行转字符串，然后连接处理&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.suggestions.aggregate([
    {
        $project: {
          year: {$year: {date:'$submitDate', timezone:'+0800'}},
          month: {$month: {date:'$submitDate', timezone:'+0800'}},
          dayOfMonth: {$dayOfMonth: {date:'$submitDate', timezone:'+0800'}},
          submitDate:1
        }
    },
    {
        $group: {
            _id:{year:'$year', month:'$month', day:'$dayOfMonth'},
            
            count: {
                $sum: 1
            }
        }
    },
    {   
        $sort : { _id : 1 }
    }   
])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;要分组的日期是timeStamp，并且为string, 网上查找的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection('wechat_message').aggregate(  
    [     
        {   $project : { day : {$substr: [&quot;$sendTime&quot;, 0, 10] }}},          
        {   $group   : { _id : &quot;$day&quot;,  number : { $sum : 1 }}},  
        {   $sort    : { _id : -1 }}          
    ]  
)  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 05 Sep 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/mongodb_skill/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mongodb_skill/</guid>
        
        <category>mongodb</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>kubernetes基础使用</title>
        <description>&lt;p&gt;kubernetes基础使用，创建一个Deployment,创建一个Service&lt;/p&gt;

&lt;h3 id=&quot;使用k8s部署一个nginx&quot;&gt;使用k8s部署一个nginx&lt;/h3&gt;

&lt;h4 id=&quot;创建一个deployment&quot;&gt;创建一个Deployment&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;controllers/nginx-deployment.yaml&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-deployment&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;必需字段&quot;&gt;必需字段&lt;/h5&gt;
&lt;p&gt;在想要创建的 Kubernetes 对象对应的 .yaml 文件中，需要配置如下的字段：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;apiVersion - 创建该对象所使用的 Kubernetes API 的版本&lt;/li&gt;
  &lt;li&gt;kind - 想要创建的对象的类型&lt;/li&gt;
  &lt;li&gt;metadata - 帮助识别对象唯一性的数据，包括一个 name 字符串、UID 和可选的 namespace&lt;/li&gt;
  &lt;li&gt;spec 字段。对象 spec 的精确格式对每个 Kubernetes 对象来说是不同的，包含了特定于该对象的嵌套字段。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#&quot;&gt;Kubernetes API&lt;/a&gt;参考能够帮助我们找到任何我们想创建的对象的 spec 格式。&lt;/p&gt;

&lt;h4 id=&quot;问题&quot;&gt;问题&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Deployment的matchLabels必选能选到template的label,否则创建资源的时候会报错。==为什么==, 因为这个Deployment选择不到对应的pod，达不到要求的replica为3，所以会不停新建template的Pod。&lt;/li&gt;
  &lt;li&gt;现在如何访问这个nginx
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl port-forward &amp;lt;podname&amp;gt; 80:80&lt;/code&gt;，使用kubectl代理，这样只有拥有k8s集群权限才行，用不了k8s也访问不到&lt;/li&gt;
      &lt;li&gt;建一个Service，下面介绍&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;创建一个service&quot;&gt;创建一个Service&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;service/nginx-service.yml&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;http&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;targetPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;nodePort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;31100&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;NodePort&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;spec.type分别有ClusterIP(default), NodePort, and LoadBalancer，
    &lt;ol&gt;
      &lt;li&gt;默认的ClusterIP会给这个Service生成一个虚拟IP,在k8s集群中，我们可以通过这个ip,或者Service的name(借助的k8s的dns解析)来访问这个服务，但我们还是无法在外部访问到这个服务&lt;/li&gt;
      &lt;li&gt;NodePort会在k8s集群中的所有Node开启一个nodePort指定的端口或者随机端口，然后我们可以拿k8s集群中任意一个机器的IP加这个nodePort就可以访问这个服务，但这个任然不是最佳的方式，因为我们需要一个额外的文件来维护不同服务的不同端口，在后面可以借助ingress，和ingress controller边缘路由器来暴露端口，并对k8s内部的服务进行反向代理。&lt;/li&gt;
      &lt;li&gt;LoadBalancer借助云服务商提供的LoadBalancer软件，将服务暴露在云服务商的LB软件上，每个厂商的配置不太相同&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 03 Sep 2019 17:53:00 +0800</pubDate>
        <link>http://localhost:4000/posts/k8s_basic_use/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/k8s_basic_use/</guid>
        
        <category>kubernetes</category>
        
        
        <category>posts</category>
        
      </item>
    
  </channel>
</rss>
