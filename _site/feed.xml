<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JiYang's Blog</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 12 Dec 2019 23:43:42 +0800</pubDate>
    <lastBuildDate>Thu, 12 Dec 2019 23:43:42 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>golang复合类型</title>
        <description>&lt;p&gt;golang的复合类型，包括数组，切片，哈希表和结构体等复合类型的使用&lt;/p&gt;

&lt;h1 id=&quot;数组array&quot;&gt;数组(Array)&lt;/h1&gt;
&lt;p&gt;数组，长度固定，包含的元素拥有一种共同类型&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;q := [...]{1,2,3}&lt;/code&gt;初始化的时候可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt;来省略长度，这时长度由后面元素的个数决定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数组的长度是它类型的一部分，[3]int和[4]int不是一个类型，数组长度必须是一个常量，也就是必须在编译的时候能确定的值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定标引结合iota定义&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Currency&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;USD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Currency&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;itoa&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EUR&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GBP&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;RMB&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;USD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;$&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EUR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;€&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GBP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;£&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RMB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;￥&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;指定特定标引，并给其他值默认值，定义100个值，最后一个是-1，其余是0&lt;code class=&quot;highlighter-rouge&quot;&gt; r:=[...]int{99: -1}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;如果数组的一个元素是可以比较的，那么这个数组类型就是可以比较，可以直接对数组使用==或者!=， 会将两个数组一个一个去比较，但[2]int和[3]int不是一个类型，不能比较&lt;/li&gt;
  &lt;li&gt;go的数组当做参数传递的时候会copy一份原数组（对于其他类型go也是这样做的），这样效率比较低，在其他语言中都是隐式的传的引用，在go中可以显示的使用指针来达到同样的效果, 尽管这样，数组也不够灵活，因为他们的长度是固定了，所以很少在func参数使用数组作为参数而是使用切片(slice)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;切片slices&quot;&gt;切片(Slices)&lt;/h1&gt;

&lt;p&gt;可变长度，所有元素拥有一种类型，轻量级的数据结构可以访问数组的子序列，包含三部分组成：指针，长度和容量，长度小于等于容量，可以使用len和cap函数获取切片的长度和容量&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;s[i:j]切片操作，s可以是一个数组，指向数组的指针或者其他切片，返回一个新的切片， 0≤i≤j≤cap(s), i和j可以单独或者同时省略，i的默认值是0，j的默认值是len(s)&lt;/li&gt;
  &lt;li&gt;s[i:j]中j超过cap(s)会报错，超过len(s)会扩展数组。&lt;/li&gt;
  &lt;li&gt;substring操作和在[]byte上面的切片是很相似的，都是s[x:y], 都返回原始字节序列的子序列，都依赖潜在数组所以花费常量时间，唯独不同的是，当s是string时返回string,当s时[]byte返回[]byte&lt;/li&gt;
  &lt;li&gt;因为切片含一个指针，当做函数参数传递的时候允许函数去修改底层数组元素，也就是说，拷贝切片创建了底层数组的一个别名&lt;/li&gt;
  &lt;li&gt;和数组不同，切片是不可比较的，对于字节切片，可以使用bytes.Equal来比较，其他类型的切片的比较需要我们自己来实现&lt;/li&gt;
  &lt;li&gt;make([]T, len, cap)可以创建一个切片，指定长度和容量，容量可以省略和长度一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;append方法&quot;&gt;append方法&lt;/h2&gt;

&lt;p&gt;append将一个元素追加到切片s里面，方法内部的机制简单如下，查看s的cap是否够大，如果够大，就使用同样的底层数组，把切片s的len加1，并把元素加入那个位置，如果不够大，就会重新分配内存建一个新的底层数组，然后将数组拷贝过去，并将新元素加入，然后返回新的切片&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为我们不能确定每次调用append方法的时候会不会重新分配内存，所以通常我们会使用append的返回值赋值给原来的切片，而不能去依赖append方法以参数引用改变切片。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s := append(s, a)  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;一些原位操作&quot;&gt;一些原位操作&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;这些操作并不会重新分配内存，而是利用原有的底层数组&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func nonempty(strings []string) []string {
	i := 0
	for _, s := range strings {
		if s != &quot;&quot; {
			strings[i] = s
			i++
		}
	}
	return strings[:i]
}
func remove(s []int, i int) []int  {
	copy(s[i:], s[i+1:])
	return s[:len(s)-1]
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;哈希表map&quot;&gt;哈希表(Map)&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;哈希表是一个无序的键值对，键是唯一的，无论表多大，根据键去检索，更新，删除值平均花费常量的时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Go的map是一个哈希表的一个引用，map[K]V, 键拥有相同的类型，值也拥有相同的类型，键和值的类型可以不同，键必须是可以比较的，这样才能确保键的唯一性，最好不要用浮点作为key, 因为浮点比较不准而且NaN不能去比较&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用make或者map字面量来生成map, 使用delete来删除，使用下标来检索&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;m := make(map[string]int)
m := map[string]int{
    &quot;haha&quot;:1,
    &quot;heihei&quot;:2
}
// delete
delete(m, &quot;haha&quot;)

// retrieve
m[&quot;haha&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;获取不了map元素的地址，其中一个原因是因为map重新哈希已有元素，使之前的地址失效&lt;/li&gt;
  &lt;li&gt;使用range来遍历map的k,v, map本身是无序的，但我们可以将key放入一个数组排序，然后按照我们排序的key取出来&lt;/li&gt;
  &lt;li&gt;查询，删除，遍历一个nil的map是安全的，但不是赋值一个nil map&lt;/li&gt;
  &lt;li&gt;和切片一样，map不能直接比较&lt;/li&gt;
  &lt;li&gt;因为map对于不存在的key是取0值的，在检索时使用第二个返回值来判断key是不是真正存在map中，如下&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if age, ok := ages[&quot;bob&quot;]; !ok {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;go没有提供set这样的类型，map的key是唯一的，可以当做set来使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;结构体struct&quot;&gt;结构体(Struct)&lt;/h1&gt;

&lt;p&gt;结构体就是有0个或者多个字段的复合类型&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;go在我们使用结构体指针的时候做了一些简化操作，不用显示写*也能使用结构体，如下&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employeeOfTheMonth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dilbert&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// dilbert is a Employee type struct, i omit the context&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;employeeOfTheMonth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Position&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxx&quot;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// is equivalent to&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;employeeOfTheMonth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Position&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxx&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;当一个方法返回一个结构体指针的时候，是可以直接方法其属性的，但返回一个结构体的时候不能，如下&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewAccount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;NewAccount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxx&quot;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//  error cannot assign to NewAccount().Name&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewAccount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;NewAccount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxx&quot;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// pass&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;结构体的字段顺序是有意义的，顺序不同则是不同的结构体&lt;/li&gt;
  &lt;li&gt;结构体类型S不能包含结构体类型S, 但可以包含结构体类型指针*S, 这样我们可以去创建一些链表和树式的类型&lt;/li&gt;
  &lt;li&gt;结构体的零值就是每个属性类型的零值&lt;/li&gt;
  &lt;li&gt;空结构体不存数据，所以会有人使用set时，用这样的结构map[string]struct{}, 但是节省空间不重要，而且这种写法很繁琐，最好不要这样写&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;结构体字面量&quot;&gt;结构体字面量&lt;/h2&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;//形式一, 简单，但需要记住属性的位置，在增加属性之后也需要调整位置&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//形式二，显示指明属性名，没指定属性的值为零值&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;结构体可以当作函数的参数传递，但遇到比较大的机构体时，为了提高效率，最好传递指针，而且当函数想要改变传入的参数时必须这么做，因为go只有值传递。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pp := &amp;amp;Point{1,2}&lt;/code&gt;创建并初始化一个Point指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;比较结构体&quot;&gt;比较结构体&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;如果结构体的所有字段都是可比较的，那么结构体就是可比较的&lt;/li&gt;
  &lt;li&gt;可比较的结构体可以作为map的key&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;结构体的内置匿名属性&quot;&gt;结构体的内置匿名属性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;结构体可以通过组合的方式来减少代码的重复性, 但这样的话，需要多个&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;符合来获取到嵌套结构体的属性&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Circle&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Center&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Radius&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Wheel&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Circle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Circle&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Spokes&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Circle&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Center&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Wheel&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CirCle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Center&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;使用匿名字段的方式可以使用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;来获取嵌套结构体的属性&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Circle&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Radius&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Wheel&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Circle&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Spokes&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Circle&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Wheel&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;但在使用字面量初始化的时候还需要些多层结构体&lt;/li&gt;
  &lt;li&gt;匿名属性不一定非得是结构体，可以是其他任意被命名的类型或者指向其的指针，匿名属性对于这些类型的意义不在于节省&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;符，而且为了继承类型的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;json&quot;&gt;JSON&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;json.Marshal(movies) 将go对象转为Json字节数组， json.MarshalIndent(movies, “”, “	“), 转为格式可读的Json字节数组，没被导出的字段不会被转化为json&lt;/li&gt;
  &lt;li&gt;字段标签, 是编译时期和结构体属性相关的元数据字符串，里面的json key控制着encoding/json的转化表现&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Year int `json: &quot;released&quot;`

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;json.Unmarshal(data, &amp;amp;titles), 将字节序列转化为go对象，这个过程对字段的忽视大小写，所以不用给那些只有大小不同的字段增加字段标签&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;文本和html&quot;&gt;文本和HTML&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;text/template和html/template包&lt;/li&gt;
  &lt;li&gt;一些表达式和使用管道符&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;对表达式进行处理&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 12 Dec 2019 23:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/composite_type/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/composite_type/</guid>
        
        <category>golang</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>5.1.1版本elasticsearch中英文排序</title>
        <description>&lt;p&gt;5.1.1版本elasticsearch中英文排序问题排查及解决&lt;/p&gt;

&lt;h1 id=&quot;环境&quot;&gt;环境&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;elasticsearch：5.1.1&lt;/li&gt;
  &lt;li&gt;分词插件mmseg: 5.1.1&lt;/li&gt;
  &lt;li&gt;拼音插件pinyin: 5.1.1&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;配置&quot;&gt;配置&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;analyzer&quot;: {
          &quot;pinyin_raw&quot;: {
            &quot;type&quot;: &quot;pinyin&quot;,
            &quot;keep_first_letter&quot;: false,
            &quot;keep_full_pinyin&quot;: false,
            &quot;keep_joined_full_pinyin&quot;: true,
            &quot;keep_none_chinese_in_joined_full_pinyin&quot;: true,
            &quot;keep_none_chinese_in_first_letter&quot;: true,
            &quot;none_chinese_pinyin_tokenize&quot;: false,
            &quot;lowercase&quot;: true
          }
          ...

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;需求&quot;&gt;需求&lt;/h1&gt;
&lt;p&gt;想对文件名进行按照字典顺序排序，文件名有中文和英文，中文使用pinyin插件转化为拼音&lt;/p&gt;

&lt;h1 id=&quot;问题&quot;&gt;问题&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;纯英文或纯数字混合分词结果多一个空格&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; http://ec2-52-81-100-48.cn-north-1.compute.amazonaws.com.cn:9200/test_new/_analyze?text=36kr&amp;amp;analyzer=pinyin_raw
 
 
 {
    &quot;tokens&quot;: [
        {
            &quot;token&quot;: &quot;36kr&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 3,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 0
        },
        {
            &quot;token&quot;: &quot;&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 0,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 1
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;英文和中文混合时，不能正确拼接在一起, 且英文总是排在最前面&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://ec2-52-81-100-48.cn-north-1.compute.amazonaws.com.cn:9200/test_new/_analyze?text=哈哈dc&amp;amp;analyzer=pinyin_raw

{
    &quot;tokens&quot;: [
        {
            &quot;token&quot;: &quot;dc&quot;,
            &quot;start_offset&quot;: 1,
            &quot;end_offset&quot;: 3,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 0
        },
        {
            &quot;token&quot;: &quot;haha&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 4,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 1
        }
    ]
}

本来应该是hahadc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;解决过程&quot;&gt;解决过程&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;问题1之前pinyin插件的issue里面有人提到过，增加一个空白过滤器就可以去掉这个空白字符 &lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-pinyin/issues/163&quot;&gt;issue&lt;/a&gt;, 我自己也尝试过有效，但这个过滤器可以不加，升级es可以解决，所以下面测试的配置还是上面的配置。&lt;/li&gt;
  &lt;li&gt;问题2查看pinyin插件的配置文档看到keep_none_chinese_in_joined_full_pinyin这个配置会将非中文和英文连接起来，但结果却没有，经过排查，发现pinyin插件5.1.1是不支持这个参数，由5.2.0的relase的commit可以看出是在这个版本才支持keep_none_chinese_in_joined_full_pinyin &lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-pinyin/compare/v5.2.0...master&quot;&gt;pinyin插件5.2.0commit记录&lt;/a&gt;, 并且解决了&lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-pinyin/issues/80&quot;&gt;#80issue&lt;/a&gt;, 在这个issue里面同时出现了上述两个问题，拼音插件的作者回复下载5.2.2可以解决上述问题&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以最终打算下载es5.2.2，并按照mmseg和pinyin5.2.2&lt;/p&gt;

&lt;h1 id=&quot;测试522分词&quot;&gt;测试5.2.2分词&lt;/h1&gt;

&lt;p&gt;在相同配置的情况下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://52.82.10.41:9200/test_new/_analyze?analyzer=pinyin_raw&amp;amp;text=36kr

{
    &quot;tokens&quot;: [
        {
            &quot;token&quot;: &quot;36kr&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 4,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 0
        }
    ]
}



http://52.82.10.41:9200/test_new/_analyze?analyzer=pinyin_raw&amp;amp;text=哈哈dc
{
    &quot;tokens&quot;: [
        {
            &quot;token&quot;: &quot;hahadc&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 6,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 0
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;已经解决了上述问题并且满足了我们的需要&lt;/p&gt;

&lt;h1 id=&quot;结论&quot;&gt;结论&lt;/h1&gt;

&lt;p&gt;分词出现空白和中英文连接不生效的情况是elasticsearch和插件版本较低导致， 我们的最终解决方式是升级elasticsearch和插件到5.2.2， 因为升级es可以会对应用整体造成影响，升级之前需要先评估应用对es的依赖性。&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Dec 2019 12:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/chinese_sort/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/chinese_sort/</guid>
        
        <category>elasticsearch</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>golang基本类型</title>
        <description>&lt;p&gt;golang基本类型， number, string, unicode, utf-8的基础知识&lt;/p&gt;

&lt;h1 id=&quot;四种类型&quot;&gt;四种类型&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;基本类型，numbers, strings, booleans&lt;/li&gt;
  &lt;li&gt;聚合类型，arrays, structs&lt;/li&gt;
  &lt;li&gt;引用类型，pointers, slices, maps, functions, channels&lt;/li&gt;
  &lt;li&gt;接口类型，interface&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;integer&quot;&gt;Integer&lt;/h1&gt;
&lt;p&gt;int8, int16, int32, int64&lt;/p&gt;

&lt;p&gt;uint8, uint16, uint32, uint64&lt;/p&gt;

&lt;p&gt;不同尺寸和有无符号的int&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;int和uint, 具体大小取决于编译器&lt;/li&gt;
  &lt;li&gt;rune, int32的同义词，很方便表示一个Unicode码点&lt;/li&gt;
  &lt;li&gt;byte, int8的同义词，重点强调是一系列的原生数据而不是一个值&lt;/li&gt;
  &lt;li&gt;uintptr, 大小不确定，但足以装下指针的值，通常用于底层编码，例如Go使用C库&lt;/li&gt;
  &lt;li&gt;int和它们的兄弟不是一种类型，需要显示转换，尽管int的底层是32位和int32一致。&lt;/li&gt;
  &lt;li&gt;数学运算符，逻辑操作符，比较操作符, 位操作符，这些和其他语言的基本相同，下面是特殊的几个
    &lt;ol&gt;
      &lt;li&gt;%, 取余操作符， 结果的符合和被除数一致， -5%3和-5%-3的结果都是-2&lt;/li&gt;
      &lt;li&gt;&amp;amp;^, 位清除操作， z = x &amp;amp;^ y   当y位1时，z位位0，否则和x的一样, 顾名思义，根据y中为1的位去清除x中的位&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;左移时空位填0，右移时空位填符号位，5右移1位是2，所以负数右移时要谨慎，-5右移1位是-3，计算机底层使用补码来存，负数的补码是对应正数的二进制按位取反再加1，正数的补码是正数的二进制&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;小知识点： &amp;amp;位操作可以用来检测某个位是不是1, 5 &amp;amp; 1 大于 0 能看出5的最右一位是1，可以通过右移5或者左移1来探测5的二进制里面有多少个1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;整型字面量可以是任何长度和类型的，（字面量的意思就是&lt;code class=&quot;highlighter-rouge&quot;&gt;a=5&lt;/code&gt;,里面的5就是字面量）0开头的是八进制，0x开头的是十六进制，八进制多用于文件权限,十六进制多强调数字的位而不是值&lt;/li&gt;
  &lt;li&gt;使用fmt.Printf的%d,%o,%x来输出十进制，八进制和十六进制&lt;/li&gt;
  &lt;li&gt;rune字面量是被单引号包起来的单个字符，可以写入ascii码&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;，也可以写入任意unicode码点例如&lt;code class=&quot;highlighter-rouge&quot;&gt;国&lt;/code&gt;, 类型是int32, 可以使用fmt.Printf的%d,%c,%q来输出十进制，字符，和引号引起来的字符&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;浮点数floating-point-numbers&quot;&gt;浮点数Floating-Point Numbers&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;float32和float64, float32提供大约6位小数精度，float64提供大约15位小数精度&lt;/li&gt;
  &lt;li&gt;特别大的数或者特别小的数应该用科学计数法&lt;/li&gt;
  &lt;li&gt;特殊数值0,-0,+Inf,-Inf,NaN, 任何和NaN的比较都是false&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;复数&quot;&gt;复数&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;complex64和complex128,&lt;/li&gt;
  &lt;li&gt;complex函数构建复数，real和imag函数去复数的实数和虚数&lt;/li&gt;
  &lt;li&gt;一个浮点字面量跟一个i就变成一个虚数字面量，例如3i,是实数为0的复数&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;布尔值&quot;&gt;布尔值&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;true和false&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;!，&amp;amp;&amp;amp;，&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;， &amp;amp;&amp;amp;的优先级高于&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;, !是单元操作符&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;逻辑布尔表达式具有短路的表现，当前面的表达式足以确定真假的时候，就不在执行后面的表达式&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;字符串&quot;&gt;字符串&lt;/h1&gt;

&lt;p&gt;字符串是不可变的一序列字节，可以包含任意数据，甚至0个字节，通常包含人类可读的文本，这些文本被解析为Utf8编码的码点（rune)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;len方法返回字符串字节的个数，而不是rune，可以通过索引访问指定位置的字节&lt;/li&gt;
  &lt;li&gt;substring操作，s[i:j]返回新字符串包含i到j(不含j)的字节，长度为j-i, i和j都可以省略，从0或者到结尾，和python的切片类似。&lt;/li&gt;
  &lt;li&gt;+操作将两个字符串进行拼接返回一个新字符串&lt;/li&gt;
  &lt;li&gt;可以使用==或者&amp;lt;进行比较，将一个字节一个字节进行比较&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;字符串的不可变性，保证了字符串的拷贝共享一份内存是安全的，所以拷贝任意长度的字符串和获取子串都是廉价的操作，它们共享着相同的内存，不会重新分配内存&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;字符串字面量&quot;&gt;字符串字面量&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;go源文件被uft8编码，所以可以在文件中直接写unicode字符&lt;/li&gt;
  &lt;li&gt;使用\来进行转义&lt;/li&gt;
  &lt;li&gt;``包裹的是原生字符串字面量，其中的内容不会被转义，适合写正则，html，json等字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unicode&quot;&gt;Unicode&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Unicode是一个收集世界上数中语言和符合的编码表，正如ASCII一样，将字符和数字进行对应起来，计算机存储数字，在需要展示给人的时候转换为字符&lt;/li&gt;
  &lt;li&gt;Unicode的每个符号对应的数字的值称为Unicode码点(Unicode code point), 在Go里面就是rune&lt;/li&gt;
  &lt;li&gt;Unicode中如果用rune（int32)来存储的话，是非常简单和正规的，这样所有字符的长度都占4个字节，然而，我们平常大多使用的字符还是2个字节就能表示的了，或者1个字节能表示的了（比如ASCII)，所有字符占4个字节会浪费很多空间，所以就出现了UTF-8编码&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;utf-8&quot;&gt;UTF-8&lt;/h2&gt;

&lt;p&gt;UTF-8是一个将Unicode码点转换为不同长度的编码，它使用1到4个字节来存储一个字符，那么这我曾经想过的一个问题是，既然一个字符的长度不同，那么在一个字节序列里面，它是如何判断边界的呢，它怎么判断这两个字节是这个字符，而这一个字节是这个字符？utf-8是这么做的，它用字节里面的高位（high-order bit)来标识下面跟着多少个字节，比如0xxxxx这样的代表着是ASCII码，下一个字节将是一个新的字符。110xxxx代表后面还跟随着两个字节，后面跟随的两个字节都是以10开头的。这样就能使用utf-8编码来节省空间。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;utf8有很多特性，使我们不用对它转为unicode也能进行获取子串，比较，从左到右读取，不必担心上下文。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Unicode&lt;/th&gt;
      &lt;th&gt;Utf-8&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;000000-00007F&lt;/td&gt;
      &lt;td&gt;0xxxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;000080-0007FF&lt;/td&gt;
      &lt;td&gt;110xxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;000800-00FFFF&lt;/td&gt;
      &lt;td&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;010000-10FFFF&lt;/td&gt;
      &lt;td&gt;11110xxx 10xxxxxx 10xxxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;许多unicode不容易写，所以go允许我们直接写数值码点，下面都是6个字节的字面量(看utf8很容易看出是6个字节，十六进制两个数是一个字节)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;世界&quot;
&quot;\xe4\xb8\x96\xe7\x95\x8c&quot;   utf8
&quot;\u4e16\u754c&quot;               16 bit unicode
&quot;\U00004e16\U0000754c&quot;       32 bit unicode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;下面都是rune字面量，256内的值可以用单个十六进制来表示，&lt;code class=&quot;highlighter-rouge&quot;&gt;\xe4\xb8\x96&lt;/code&gt;虽然是一个utf8编码的码点，但不是一个有效的rune字面量&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'世', '\u4e16', '\U00004e16'
'\x41'

'\xe4\xb8\x96' // 不是rune字面量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;对于字符串直接使用索引遍历，遍历的是字节，而可用使用range来遍历rune, utf8.RuneCountInString可以返回某个字节rune的个数&lt;/li&gt;
  &lt;li&gt;当utf8在解码时碰到错误的字节会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;\uFFFD&lt;/code&gt;来代替，是一个�这样的符号，当碰到了这样的符号，说明其他系统传过来的字节编码可能是不清楚的&lt;/li&gt;
  &lt;li&gt;rune和string相互转化&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s:=&quot;哈哈&quot;
r:=[]rune(s)   // string =&amp;gt; rune utf8 decode
string(r)      // rune =&amp;gt; string utf8 encode
string(65)     // &quot;A&quot;  integer =&amp;gt; string
string(0x4eac) // &quot;京&quot;  0x4eac也是integer字面量
string(1234567)// � 无效
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;字符和字节切片&quot;&gt;字符和字节切片&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;四个重要的标准包
    &lt;ol&gt;
      &lt;li&gt;strings,对字符串基本的查找，替换，比较，去空，分割，结合操作&lt;/li&gt;
      &lt;li&gt;bytes，对[]byte有相同的操作&lt;/li&gt;
      &lt;li&gt;strconv，负责boolean, int, float等类型转换到string&lt;/li&gt;
      &lt;li&gt;unicode, 对rune的各种操作&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;因为string是不可变的，所以当想通过不断累积的方式获取新的string需要不停的分配内存，使用bytes.Buffer效率更好&lt;/li&gt;
  &lt;li&gt;下面的方式可以将string和[]byte互转，在转化的过程中，重新分配内存和拷贝是必要的，因为[]byte是可以改变的&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s := &quot;abc&quot;
b := []byte(s)
s2 := string(b)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;数字和字符串转换&quot;&gt;数字和字符串转换&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;两种将数字转换为字符串的方式，fmt.Sprintf和strconv.Itoa&lt;/li&gt;
  &lt;li&gt;strconv.FormatInt可以将数字转换为不同的进制，fmt.Sprintf的%b, %d, %u, %x也可以将数字转换为特定的进制，而且还可以加入一些额外的信息&lt;/li&gt;
  &lt;li&gt;strconv.Atoi和strconv.ParseInt可以将字符串的数字转换为数字，ParseInt可以指定进制和返回的尺寸&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;常量&quot;&gt;常量&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;在编译时期就能确定的值&lt;/li&gt;
  &lt;li&gt;常量的类型既可以显示声明，也可以根据值来进行推断&lt;/li&gt;
  &lt;li&gt;iota, 常量生成器，在常量变量自动生成自动增长的值，声明一些规律的常量很好用，比如周一到周日，KiB,MiB,GiB这些单位。iota依赖左移和右移运算符来完成某些操作，所以对于KB,MB这些值是1000的是无法用iota声明的（KiB和KB的区别，一个是1024,一个是1000，但之前学习的时候KB指的是1024， 默认KB是KiB)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;无类型常量&quot;&gt;无类型常量&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;常量是可以无类型的，无类型意思就是类型在用的时候才显式或者隐式转换，比如0这个常量，赋值给int，它就是int类型，赋值给float64, 它就是float64类型&lt;/li&gt;
  &lt;li&gt;六种无类型常量，无类型布尔，无类型整形，无类型rune, 无类型float, 无类型复数，无类型字符串&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Dec 2019 12:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/basic_type/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/basic_type/</guid>
        
        <category>golang</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>mongodb工具，安全，故障</title>
        <description>&lt;p&gt;mongodb导入和导入工具，监控工具，授权认证，故障排除&lt;/p&gt;

&lt;h3 id=&quot;安全&quot;&gt;安全&lt;/h3&gt;

&lt;h4 id=&quot;用户&quot;&gt;用户&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;创建第一个用户&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; db.createUser(
... {
... user: &quot;myUserAdmin&quot;,
... pwd: &quot;passwd&quot;,
... roles: [ &quot;userAdminAnyDatabase&quot;]
... }
... )
Successfully added user: { &quot;user&quot; : &quot;myUserAdmin&quot;, &quot;roles&quot; : [ &quot;userAdminAnyDatabase&quot; ] }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;认证&quot;&gt;认证&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在mongod启动时加入–auth参数开启登录验证&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用用户名和密码进行身份验证&lt;/p&gt;

    &lt;p&gt;mongo -u “myUserAdmin” -p “passwd” –authenticationDatabase “admin”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;authenticationDatabase表示创建用户使用的数据库，但不是指定该用户权限的。&lt;/li&gt;
  &lt;li&gt;如果目的既是登陆test数据库，而用户也是test数据库中创建，那么可以不用写后面的参数 –authenticationDatabase&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;授权&quot;&gt;授权&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;权限 = 在哪里 + 做什么&lt;/p&gt;

    &lt;p&gt;{resource:{db:”test”, collections: “”}, actions:[“find”, “update”]}&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;角色，一组权限的集合
    &lt;ol&gt;
      &lt;li&gt;read, 读取当前数据库中所有非系统集合&lt;/li&gt;
      &lt;li&gt;readWrite, 读写当前数据库中所有非系统集合&lt;/li&gt;
      &lt;li&gt;dbAdmin, 管理当前数据库&lt;/li&gt;
      &lt;li&gt;userAdmin, 管理当前数据库中的用户和角色&lt;/li&gt;
      &lt;li&gt;read/readWrite/dbAdmin/userAdminAnyDatabase 对所有数据库执行操作（只在admin数据库提供）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;创建一个只能读取test数据库的用户&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use test;
db.createUser(
    {
        user: &quot;testReader&quot;,
        pwd: &quot;passwd&quot;,
        roles: [{role: &quot;read&quot;, db: &quot;test&quot;}]
    }
)

Successfully added user: {
	&quot;user&quot; : &quot;testReader&quot;,
	&quot;roles&quot; : [
		{
			&quot;role&quot; : &quot;read&quot;,
			&quot;db&quot; : &quot;test&quot;
		}
	]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;创建一个只能读取accounts集合的用户&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use test;
db.createRole(
    {
        role: &quot;readAccount&quot;,
        privileges: [
            {
                resource: {
                    db:&quot;test&quot;, 
                    collection: &quot;accounts&quot;
                },
                actions: [&quot;find&quot;]
            }
        ],
        roles: []
    }
)
use test;
db.createUser(
    {
        user: &quot;accountsReader&quot;,
        pwd: &quot;passwd&quot;,
        roles: [&quot;readAccount&quot;]
    }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;roles字段可以从已有角色中继承权限&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;工具&quot;&gt;工具&lt;/h2&gt;

&lt;h4 id=&quot;数据导入导出&quot;&gt;数据导入导出&lt;/h4&gt;
&lt;h5 id=&quot;mongoexport&quot;&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongoexport/&quot;&gt;mongoexport&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&quot;mongoimport&quot;&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongoimport/index.html&quot;&gt;mongoimport&lt;/a&gt;&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;upsertFileds 根据特定字段去对比从而选择去更新还是插入&lt;/li&gt;
  &lt;li&gt;stopOnError 发送错误停止&lt;/li&gt;
  &lt;li&gt;maintainInsertionOrder 维持csv的顺序导入&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;监控&quot;&gt;监控&lt;/h4&gt;

&lt;h5 id=&quot;mongostat统计mongodb数据库当前的状态&quot;&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongostat/index.html&quot;&gt;mongostat&lt;/a&gt;，统计mongodb数据库当前的状态&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;需要用户有clusterMonitor的角色&lt;/li&gt;
  &lt;li&gt;可以指定打印间隔和次数&lt;/li&gt;
  &lt;li&gt;o指定需要查看的指标
    &lt;ol&gt;
      &lt;li&gt;commman - 每秒执行的命令数&lt;/li&gt;
      &lt;li&gt;dirty, used - 数据库引擎缓存的使用量百分比&lt;/li&gt;
      &lt;li&gt;vsize - 虚拟内存使用量（MB)&lt;/li&gt;
      &lt;li&gt;res - 常驻内存使用量&lt;/li&gt;
      &lt;li&gt;conn - 连接数&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;mongotop显示每个集合上的读写时间&quot;&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongotop/index.html&quot;&gt;mongotop&lt;/a&gt;,显示每个集合上的读写时间&lt;/h5&gt;

&lt;h2 id=&quot;故障&quot;&gt;故障&lt;/h2&gt;

&lt;h5 id=&quot;响应时间过长&quot;&gt;响应时间过长&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;合适的索引，使用explain()查看索引的有效性&lt;/li&gt;
  &lt;li&gt;工作集超出RAM的大小，使用mongostat查看服务的状态，used百分比远远大过dirty的百分比时，表示mongo内存不够使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;连接失败&quot;&gt;连接失败&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;默认情况下，mongod进程可以支持多达65536个连接，不恰当的&lt;strong&gt;配置&lt;/strong&gt;可能限制连接数
    &lt;ol&gt;
      &lt;li&gt;db.serverStatus().connections可查看连接数&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;ulimt -a配置中间的open files也会限制mongodb的连接数&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Sep 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/mongodb_tool_security/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mongodb_tool_security/</guid>
        
        <category>mongodb</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>mongodb技巧</title>
        <description>&lt;p&gt;mongodb的一些技巧&lt;/p&gt;

&lt;h2 id=&quot;按日期分组&quot;&gt;按日期分组&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;要分组的日期是Date类型的&lt;/li&gt;
  &lt;li&gt;注意timezone, +0800代表中国时区&lt;/li&gt;
  &lt;li&gt;group的_id可以进行转字符串，然后连接处理&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.suggestions.aggregate([
    {
        $project: {
          year: {$year: {date:'$submitDate', timezone:'+0800'}},
          month: {$month: {date:'$submitDate', timezone:'+0800'}},
          dayOfMonth: {$dayOfMonth: {date:'$submitDate', timezone:'+0800'}},
          submitDate:1
        }
    },
    {
        $group: {
            _id:{year:'$year', month:'$month', day:'$dayOfMonth'},
            
            count: {
                $sum: 1
            }
        }
    },
    {   
        $sort : { _id : 1 }
    }   
])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;要分组的日期是timeStamp，并且为string, 网上查找的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection('wechat_message').aggregate(  
    [     
        {   $project : { day : {$substr: [&quot;$sendTime&quot;, 0, 10] }}},          
        {   $group   : { _id : &quot;$day&quot;,  number : { $sum : 1 }}},  
        {   $sort    : { _id : -1 }}          
    ]  
)  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 05 Sep 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/mongodb_skill/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mongodb_skill/</guid>
        
        <category>mongodb</category>
        
        
        <category>posts</category>
        
      </item>
    
  </channel>
</rss>
