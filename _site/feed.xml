<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JiYang's Blog</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 03 Jul 2019 16:29:59 +0800</pubDate>
    <lastBuildDate>Wed, 03 Jul 2019 16:29:59 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>kubernetes基础概念和命令</title>
        <description>&lt;p&gt;kubernetes基础，包括kubectl命令和kubenetes的组件的概念，Pod, Node, Service等。&lt;/p&gt;

&lt;h4 id=&quot;kubectl-基本命令&quot;&gt;kubectl 基本命令&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;kubectl [command] [TYPE] [NAME] [flags]&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl create -f mysql-&amp;lt;xx&amp;gt;.yaml&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;根据yaml文件创建一个RC(ReplicationController), 或者Service, 取决于yaml文件中的kind属性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl get &amp;lt;resource&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;查看资源的大概情况,&lt;code class=&quot;highlighter-rouge&quot;&gt;-o yaml&lt;/code&gt;可以输出一个yaml格式。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl describe &amp;lt;resource&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;描述资源的详细信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl delete &amp;lt;rc或svc&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删除一个RC或者Service&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl scale rc my-web --replicas=3&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;动态调整RC副本数量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;resource可以为pods, rc, nodes, svc, deployments, endpoints(切点), rs(新版本中的RC，支持集合Label selector)等，一般单复数形式都可以&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-n&lt;/code&gt;命名空间，不写时为默认命名空间，系统命名空间为kube-system，使用可以查看一些系统的资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;kubenetes组成&quot;&gt;kubenetes组成&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Master 控制节点
    &lt;ol&gt;
      &lt;li&gt;Kubernetes API Server，提供Rest接口，所有资源增删改查的唯一入口&lt;/li&gt;
      &lt;li&gt;Kubernetes Controller Manager，资源对象的自动化控制中心&lt;/li&gt;
      &lt;li&gt;Kubernetes Scheduler，负责资源调度(Pod调度)&lt;/li&gt;
      &lt;li&gt;etcd，资源数据的保存&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Node 工作节点
    &lt;ol&gt;
      &lt;li&gt;kubelet，负责容器创建、启停，与Master沟通&lt;/li&gt;
      &lt;li&gt;kube-proxy, 实现Kubernetes Service的通信和负载均衡&lt;/li&gt;
      &lt;li&gt;Docker Engine, 负责容器创建和管理&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Pod 基本单位
    &lt;ol&gt;
      &lt;li&gt;Pause容器，代表整个Pod的状态，共享IP，Volume&lt;/li&gt;
      &lt;li&gt;用户的N个业务容器&lt;/li&gt;
      &lt;li&gt;Endpoint = Pod IP + contrainerPort，代表服务进行的对外通信地址&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Label 标签
    &lt;ol&gt;
      &lt;li&gt;用户自定义的key-value键值对，可以附加到Node, Pod, Service, RC等资源对象上面&lt;/li&gt;
      &lt;li&gt;LabelSelector可以通过=, in, not in等匹配条件来获取到特定的资源&lt;/li&gt;
      &lt;li&gt;kube-controller进程通过资源对象RC定义的Label Selector来筛选要监控的Pod副本数量&lt;/li&gt;
      &lt;li&gt;kube-proxy进行通过Service的Label Selector来选择对应的Pod，自定建议起每个Service到Pod的请求转发路由表&lt;/li&gt;
      &lt;li&gt;Node定义特定Lable，Pod的NodeSelector，kube-scheduler实现定向调度&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Deployment 部署
    &lt;ol&gt;
      &lt;li&gt;RC的一次升级，和RC相似度超过90%&lt;/li&gt;
      &lt;li&gt;相对于RC最大的升级是可以随时知道Pod部署的进度&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Horizontal Pod Autoscaler(HPA) 横向自动扩容
    &lt;ol&gt;
      &lt;li&gt;Pod横向自动扩容，通过追踪Pod的负载情况来确定是否针对调整目标Pod的副本数&lt;/li&gt;
      &lt;li&gt;通过CPUUtilizationPercetage或者应用自定义度量指标来确定是否需要扩容或者缩容&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;StatefulSet 有状态集群
    &lt;ol&gt;
      &lt;li&gt;类似Deployment,但用于有状态的集群，例如MySQL集群，MongoDB集群，Akka集群等&lt;/li&gt;
      &lt;li&gt;建立的Pod有稳定，唯一的网络标识&lt;/li&gt;
      &lt;li&gt;启停顺序是受控的&lt;/li&gt;
      &lt;li&gt;使用PV或者PVC来做数据的持久化，PV为PersistentVolum, PVC为PersistentVolumeClaim&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Service 服务
    &lt;ol&gt;
      &lt;li&gt;微服务，Pod和RC都是为了支持服务&lt;/li&gt;
      &lt;li&gt;NodeIp(每个节点物理网卡的IP地址), PodIp(虚拟的二层网络), ClusterIp(虚拟的IP,无法被ping,只能和Service Port组成一个具体的通信端口)&lt;/li&gt;
      &lt;li&gt;PodIp和ClusterIp是无法在k8s集群外访问的，要想访问，就得使用NodePort类型的Service,&lt;/li&gt;
      &lt;li&gt;NodePort在k8s的集群的每个Node建立一个访问端口，我们只要访问任意一台Node就可以访问，但还需要一个负载均衡，可以将NodePort类型改为LoadBalancer，利用公有云提供的服务来实现负载均衡。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Job 任务
    &lt;ol&gt;
      &lt;li&gt;批处理任务通常并行或者串行启动多个计算进程去处理一批工作项, 与RC, Deployment, RS类似，不过是一个特殊的Pod控制器&lt;/li&gt;
      &lt;li&gt;Job控制的Pod是短暂运行的&lt;/li&gt;
      &lt;li&gt;k8s的1.5版本后提供了CronJob&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Volume 存储卷
    &lt;ol&gt;
      &lt;li&gt;Volume是Pod中能被多个容器访问的共享目录，和Docker的Volume类似，但不能等价。&lt;/li&gt;
      &lt;li&gt;和Pod生命周期相同，和容器生命周期无关&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Persistent Volume 网络存储
    &lt;ol&gt;
      &lt;li&gt;每个Node都可以访问，独立于Pod之外，类似网盘&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Namespace 命名空间
    &lt;ol&gt;
      &lt;li&gt;实现多租户的资源隔离&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Annoation 注解
    &lt;ol&gt;
      &lt;li&gt;和Label类似，Label具有严格的命名规则，Annoation是用户定义的任意附加信息， 以便于外部工具查找&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;ConfigMap
    &lt;ol&gt;
      &lt;li&gt;集中化的配置，解决了Docker容器只能使用环境变量或者共享文件的形式将一些配置传入容器内&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 03 Jul 2019 17:53:00 +0800</pubDate>
        <link>http://localhost:4000/posts/k8s_basic/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/k8s_basic/</guid>
        
        <category>kubernetes</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>mongodb聚合操作</title>
        <description>&lt;p&gt;mongodb的一些聚合（aggregate）操作的基本使用&lt;/p&gt;

&lt;h2 id=&quot;聚合&quot;&gt;聚合&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{ &amp;lt;operator&amp;gt;: [&amp;lt;argument1&amp;gt;, &amp;lt;argument2&amp;gt;...]}&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;聚合操作&quot;&gt;聚合操作&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;db.collection.aggregate(&amp;lt;pipeline&amp;gt;, &amp;lt;optinos&amp;gt;)&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;字段路径表达式&quot;&gt;字段路径表达式&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;field&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;使用$来指示字段路径&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;field&amp;gt;.&amp;lt;sub-field&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;使用$和.来指示内嵌文档字段路径&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;系统变量表达式&quot;&gt;系统变量表达式&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$$&amp;lt;variable&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;使用$$来指示系统变量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;常量表达式&quot;&gt;常量表达式&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$literal: &amp;lt;variable&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;如果variable带$开头会被当成字段路径表达式，此种写法可以有类似转义的功能&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;聚合管道阶段&quot;&gt;聚合管道阶段&lt;/h4&gt;

&lt;h5 id=&quot;project&quot;&gt;$project&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    db.acccounts.aggregate( [
        {
            $project: {
                _id: 0,    // 不输出_id
                balance: 1, // 输出balance
                clientName: &quot;$name.firstName&quot; //将name.firstName映射到clientName字段上面
            }
        }
    ])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    db.acccounts.aggregate( [
        {
            $project: {
                _id: 0,    // 不输出_id
                balance: 1, // 输出balance
                nameArray: [ &quot;$name.firstName&quot;, &quot;$name.middleName&quot;, &quot;$name.lastName&quot;] 
                //输出一个数组,取文档中的值，当文档对应字段不存在时输出null
            }
        }
    ])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;match&quot;&gt;$match&lt;/h5&gt;
&lt;p&gt;和前面的条件筛选一致&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;应该在最开始的使用match,一是剔除不关心的数据，二是提高聚合的效率&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;limit&quot;&gt;$limit&lt;/h5&gt;
&lt;h5 id=&quot;skip&quot;&gt;$skip&lt;/h5&gt;

&lt;h5 id=&quot;unwind&quot;&gt;$unwind&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    db.acccounts.aggregate( [
        {
            $unwind: {
              path: &quot;$currency&quot;,
              // 将一个数组展开
              includeArrayIndex: &quot;ccyIndex&quot;
              // 在展开时添加元素位置
            }
        }
    ])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;当unwind字段不存在，或者为null,或者为空数组的时候不会显示出来，设置preserveNullAndEmptyArrays为true的时候会将这个文档显示出来&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;sort&quot;&gt;$sort&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;1为从小到大排序，-1为从大到小排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;lookup&quot;&gt;$lookup&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;格式一
```
  $lookup: {
      from: &lt;collection to=&quot;&quot; join=&quot;&quot;&gt;,
      localFiedld: &lt;field from=&quot;&quot; the=&quot;&quot; input=&quot;&quot; documents=&quot;&quot;&gt;,
      foreignField: &amp;lt;field from the documents of the &quot;from&quot; collection&amp;gt;,
      as: &lt;output array=&quot;&quot; field=&quot;&quot;&gt;
  }&lt;/output&gt;&lt;/field&gt;&lt;/collection&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 将查询到的外汇汇率写入银行账户文档

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.accounts.aggregate([
    $lookup: {
        from: forex,   // 另一集合的名称
        localField: currency,   //本集合要匹配的字段
        foreignField: ccy,    // 另一个集合要匹配的字段
        as: forexData  //匹配上之后，forex将被当做内嵌文档插入本集合，名称则为该值
    }
]) ``` - 格式二 ```
$lookup: {
    from: &amp;lt;collection to join&amp;gt;,
    let: { &amp;lt;var_1&amp;gt;: &amp;lt;expression&amp;gt;,..., &amp;lt;var_n&amp;gt;: &amp;lt;expression&amp;gt;},
    pipeline: &amp;lt;pipeline to execute on the collection to join&amp;gt;,
    // 满足pipeline的文档才会被插入本文档
    as: &amp;lt;output array field&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; - 将特定日期外汇汇率写入余额大于100的银行账户文档
 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$lookup: {
    from: &quot;forex&quot;
    let: { bal: &quot;$balance&quot;},
    pipeline:[
    {
        $match: {
            $expr: {  //使用let中的变量的前提
                $and: [
                    {$eq: [&quot;date&quot;, new Date(&quot;2018-12-21&quot;)]},
                    {$gt: [&quot;$$bal&quot;, 100]}  //使用let中声名的变量
                ]
            }
        }
    }
    ]
    as: &quot;forexData&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
##### $group

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$group: {
    _id: &amp;lt;expression&amp;gt;,
    &amp;lt;field1&amp;gt;: { &amp;lt;accumulator1&amp;gt;: &amp;lt;expression1&amp;gt; }
} ``` - 按照交易货币来分组交易 ```
db.transaction.aggregate([
    {
        $group: {
            _id: &quot;$currency&quot;
        }
    }
]) ``` - 使用聚合操作符计算分组聚合值 ```
db.transactions.aggregate([
    {
        $group: {
            // 按照currency分组
            _id: &quot;$currency&quot;,
            // qty字段的和，赋值到新字段totalQty
            totalQty: { $sum: &quot;$qty&quot; },
            // price和qty相乘，然后求和再赋值到totalNotional
            totalNotional: {$sum: {$multiply [ &quot;$price&quot;, &quot;$qty&quot;]}},
            // price的平均值
            avgPrice: { $avg: &quot;$price&quot;}
            // 文档的数量
            count: {$sum : 1},
            // 最大金额
            maxNotional: {$max: {$multiply: [&quot;$price&quot;, &quot;$qty&quot;] }},
            // 最小金额 
            minNotional: {$min: {$multiply: [&quot;$price&quot;, &quot;$qty&quot;] }}
        }
    }
]) ``` - 如果想聚合但不分组时，可以将_id设置为null,这是所有的文档会当做一个组 - 可以和push配合创建一个新的数组 - $out可以将查询的内容写入一个新的集合，当新的集合存在时，会将文档覆盖，当管道阶段遇到错误，则新集合不会被创建，旧集合也不会被覆盖
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;聚合选项&quot;&gt;聚合选项&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;allowDiskUse: &amp;lt;boolean&amp;gt;&lt;/code&gt;, 每个聚合管道阶段使用的内存不能超过100MB,如果数据量较大，为了防止聚合管道阶段超出内存上限并且抛出错误，可以用该选项&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;聚合操作优化&quot;&gt;聚合操作优化&lt;/h4&gt;
&lt;h5 id=&quot;顺序优化&quot;&gt;顺序优化&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;$match阶段会尽量在$project阶段之前运行，但有些条件必须在project之后则不能被优化&lt;/li&gt;
  &lt;li&gt;$match阶段会在$sort阶段之前运行&lt;/li&gt;
  &lt;li&gt;$skip阶段会在$project阶段之前运行
    &lt;h5 id=&quot;合并优化&quot;&gt;合并优化&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;$sort和$limit之间没有夹杂着改变文档数量的聚合阶段，阶段可以合并，unwind和match时可以改变文档数量的操作&lt;/li&gt;
  &lt;li&gt;相同的阶段可以合并，limit, skip, match&lt;/li&gt;
  &lt;li&gt;lookup和unwind， 如果应用在lookup阶段创建的as字段上面，两则可以合并&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 26 Apr 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/mongodb_aggregate/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mongodb_aggregate/</guid>
        
        <category>mongodb</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>mongodb增删改查</title>
        <description>&lt;p&gt;mongodb的基本增删改查操作&lt;/p&gt;

&lt;h2 id=&quot;查询&quot;&gt;查询&lt;/h2&gt;

&lt;h4 id=&quot;字段操作符&quot;&gt;字段操作符&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{field : {$type : &amp;lt;BSON type&amp;gt;}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;匹配对应类型的字段的文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{field : {$exists : bool }&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;匹配对应字段存在或者不存在的文档&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;数组操作符&quot;&gt;数组操作符&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{field : {$all :[&amp;lt;value1&amp;gt;, &amp;lt;value2&amp;gt;]}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;所以value都在field数组中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{field : {$elemMatch :{&amp;lt;query1&amp;gt;, &amp;lt;query2&amp;gt;}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;数组中元素满足多个query&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;运算操作符&quot;&gt;运算操作符&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{field : {: /pattern/, : '&amp;lt;options&amp;gt;'}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;正则匹配&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{field : {: /pattern/&amp;lt;options&amp;gt;}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;正则匹配，可以和$in使用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;find方法会返回一个游标对象Cursor，可以使用索引直接获取对应位置的文档，游标会在遍历完所有的文档或者10分钟之后关闭&lt;/li&gt;
  &lt;li&gt;游标常用方法，&lt;code class=&quot;highlighter-rouge&quot;&gt;hasNext(), next(), forEach(function), limit(number), skip(offset)， count(applySkipLimit)&lt;/code&gt;, limit传入0时会返回所有文档, applySkipLimit设置为true时会考虑skip和limit来计算count,默认为false&lt;/li&gt;
  &lt;li&gt;在不提供筛选条件的时候，cursor.count()会从集合的元数据Metadata中获取结果，当数据库分布式结构比较复杂时，元数据中的文档数量可能不准确，这种情况下应该使用局和管道来计算文档数量&lt;/li&gt;
  &lt;li&gt;sort({field:1, field:-1}) 1表示从小到大排序，-1逆向&lt;/li&gt;
  &lt;li&gt;skip()命令在limit()之前执行，即时命令的顺序是相反的， sort()命令肯定在skip和limti命令之前执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;投影&quot;&gt;投影&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;{ field: 1} 1表示希望出现的字段， 0表示不希望出现，文档主键是默认出现的可以使用0来去除&lt;/li&gt;
  &lt;li&gt;不能同时使用包含和不包含，除了文档主键之外&lt;/li&gt;
  &lt;li&gt;$slide，可以对于数组使用，接收一个数字或者数组，表示这个数组对应索引的值，可以使用负数，负索引和python中功能类似&lt;/li&gt;
  &lt;li&gt;$elemMatch, 数组字段中满足筛选条件的第一个元素&lt;/li&gt;
  &lt;li&gt;$,  使用filter中的筛选条件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;更新&quot;&gt;更新&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;db.collection.update(&amp;lt;query&amp;gt;, &amp;lt;update&amp;gt;, &amp;lt;options&amp;gt;)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;update&amp;gt;&lt;/code&gt;文档不包含任何更新操作符， db.collection.update会将&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;update&amp;gt;&lt;/code&gt;文档替换数据库中的文档&lt;/li&gt;
  &lt;li&gt;主键_id是不可以更改的&lt;/li&gt;
  &lt;li&gt;如果在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;update&amp;gt;&lt;/code&gt;文档中想包含_id字段，则_id值一定要和被更新的文档_id值保持一致&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;update&amp;gt;&lt;/code&gt;替换整篇被更新文档时，只有==第一篇==符合&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;query&amp;gt;&lt;/code&gt;的文档筛选条件的文档会被更新&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;文档更新操作符&quot;&gt;文档更新操作符&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$set: { &amp;lt;field1&amp;gt;: &amp;lt;value1&amp;gt;, ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;设置一个字段的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$unset: { &amp;lt;field1&amp;gt;: &quot;&quot;, ...}} &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;设置一个字段的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$rename: { &amp;lt;field1&amp;gt;: &amp;lt;newName1&amp;gt;, ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;对字段重命名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$inc: { &amp;lt;field1&amp;gt;: &amp;lt;amonut1&amp;gt;, ...}} &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;增加或者减少&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$mul: { &amp;lt;field1&amp;gt;: &amp;lt;number1&amp;gt;, ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;相乘&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$min: { &amp;lt;field1&amp;gt;: &amp;lt;value1&amp;gt;, ...}}  &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;选择原值和新值最小的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$max: { &amp;lt;field1&amp;gt;: &amp;lt;value1&amp;gt;, ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;选择原值和新值最大的值&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;set可以更新普通字段，内嵌文档（使用.property)，数组(使用.index),可以使用index大于数据库中的长度来增加元素，跳过某些index增加元素&lt;/li&gt;
  &lt;li&gt;unset中field的值没有任何影响&lt;/li&gt;
  &lt;li&gt;unset如果字段在文档中不存在，将不会产生影响&lt;/li&gt;
  &lt;li&gt;unset对数组删除操作时，数组的长度不会被改变，而是对于位置的值被赋为null&lt;/li&gt;
  &lt;li&gt;rename的原字段不存在，将不会对文档产生影响&lt;/li&gt;
  &lt;li&gt;rename的新字段在文档中存在，则新字段原本的内容将消失，成为原字段的内容，相当于先unset再set操作&lt;/li&gt;
  &lt;li&gt;rename可以将一个字段从一个内嵌文档中取出来或者放进去，但是不可用于数组内的对象，无论是拿出来还是放进去&lt;/li&gt;
  &lt;li&gt;inc和mul只能用于number类型的&lt;/li&gt;
  &lt;li&gt;inc如果字段在文档中不存在，将会将值赋给定值，mul不存在会将值赋0&lt;/li&gt;
  &lt;li&gt;min和max可以用于其他可以比较的类型字段，如日期等&lt;/li&gt;
  &lt;li&gt;min和max的字段在文档中不存在时，和set效果相同&lt;/li&gt;
  &lt;li&gt;min和max的更新的字段类型和原字段类型不一致时，会按照BSON数据类型排序规则进行比较，Null —&amp;gt; Regular Expression&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;数组更新操作符&quot;&gt;数组更新操作符&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$addToSet: { &amp;lt;field1&amp;gt;: &amp;lt;value1&amp;gt;, ...}} &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;向数组增加一个值，如果重复，则不添加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$pop: { &amp;lt;field1&amp;gt;: &amp;lt;-1| 1&amp;gt;, ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;从头或者尾移除一个数组元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$pull: { &amp;lt;field1&amp;gt;: &amp;lt;value|condition&amp;gt;, ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;从数组字段删除特定元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$pullAll: { &amp;lt;field1&amp;gt;: [&amp;lt;value1&amp;gt;, &amp;lt;value2&amp;gt;] ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;从数组字段删除特定元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$push: {&amp;lt;field1&amp;gt;: &amp;lt;value1&amp;gt;, ...} } &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;向数组增加一个元素&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;addToSet增加内嵌文档时，内嵌文档的属性和值完全一样时才不会增加进去，顺序颠倒内嵌文档还是会被插入进数组&lt;/li&gt;
  &lt;li&gt;addToSet可以和each关键字配合将多个字段插入数组，&lt;code class=&quot;highlighter-rouge&quot;&gt;{$addToSet:{field: {$each:[value1,value2]}}}&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;{$addToSet: {field:[value1, value2]}}&lt;/code&gt;这种写法会讲一个内嵌数组插入field数组&lt;/li&gt;
  &lt;li&gt;pop 1删除结尾元素， -1删除开头元素， 可以使用在内嵌数组上面&lt;/li&gt;
  &lt;li&gt;pop删除完所有元素会留下一个空数组&lt;/li&gt;
  &lt;li&gt;pull是要删除field的元素，不用使用elemMatch，使用elemMatch表示在field类型的数组的元素进行筛选&lt;/li&gt;
  &lt;li&gt;pullAll相当于pull加in&lt;/li&gt;
  &lt;li&gt;pull和pullAll删除内嵌数组时，需要内嵌数组的顺序和值完全相同&lt;/li&gt;
  &lt;li&gt;pullAll删除内嵌文档，内嵌文档必须顺序和值完全相同， 而pull删除内嵌文档，主要内嵌文档部分匹配，顺序也可以不一致。&lt;/li&gt;
  &lt;li&gt;push和addToSet一样，如果字段不存在，这个字段会被增加到原文档中，也可以each命令配合将多个值增加到数组&lt;/li&gt;
  &lt;li&gt;push可以和each命令，position命令搭配使用从指定位置开始插入，position可以接受负数，-1表示最后一个元素的前面&lt;/li&gt;
  &lt;li&gt;push可以和each命令， sort命令搭配使用在插入新元素后并按从小到大排序，或者从大到小。在插入内嵌文档时，sort可以对内嵌文档的字段进行排序。如果只想排序的话，each的值可以设置为空数组就可以达到要求的效果&lt;/li&gt;
  &lt;li&gt;push可以和each命令，slice命令截取部分数组&lt;/li&gt;
  &lt;li&gt;postion,sort,slice命令的顺序执行顺序从大到小&lt;/li&gt;
  &lt;li&gt;set中$指定匹配条件的元素， $[]执行所有元素&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;更新文档选项&quot;&gt;更新文档选项&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;header 1&lt;/th&gt;
      &lt;th&gt;header 2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{multi: &amp;lt;boolean&amp;gt;}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;更新多个文档，默认所有更新都只针对一篇文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{upsert: &amp;lt;boolean&amp;gt; }&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;更新或者创建文档，update没有匹配到文档的时候，就会创建一篇文档&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;更新文档只能保证单个文档操作的原子性，不能保证多个文档操作的原子性&lt;/li&gt;
  &lt;li&gt;upsert的时候当匹配条件是一个精确的内容时会将匹配条件当成文档的一部分，而匹配的条件是一个模糊的内容时，如大于，小于等，就不会将匹配条件插入文档&lt;/li&gt;
  &lt;li&gt;save命令， 文档中包含_id字段时，相当于执行一个带upsert选项的update命令&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;删除&quot;&gt;删除&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;db.collection.remove({query},{option})&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;db.colletion.drop({writeConcern: &amp;lt;document&amp;gt;)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在默认情况下，remove命令会删除所有符合筛选条件的文档&lt;/li&gt;
  &lt;li&gt;如果只想删除一篇，可以使用justOne&lt;/li&gt;
  &lt;li&gt;在文档数较多时drop的效率比remove的效率高&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 26 Apr 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/mongodb_crud/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mongodb_crud/</guid>
        
        <category>mongodb</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>vim工具</title>
        <description>&lt;p&gt;Vim的一些插件和工具&lt;/p&gt;

&lt;h4 id=&quot;ctags&quot;&gt;ctags&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;c语言代码标签功能&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew install ctags&lt;/code&gt;命令安装在macos下&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ctags *.rb&lt;/code&gt;  在命令行生成标签文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:!ctags -R&lt;/code&gt; 在vim内生成标签文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:nnoremap &amp;lt;f5&amp;gt; :!ctags -R&amp;lt;CR&amp;gt; &lt;/code&gt;将生成标签文件映射为f5键&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:autocmd BufWritePost * call system(&quot;ctags -R&quot;)&lt;/code&gt; 文件保存的时候自动执行&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-]&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;跳转到代码的定义出&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-t&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;:pop&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;按照原来的标签历史返回&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gC-]&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;如果有多个定义，则会显示一个列表让你选择&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:tselect&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;拉取出可供选择的定义列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:tprev&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;:tnext&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;:tfirst&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;:tlast&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;跳转到相应的定义&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:tag {keyword}&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;:tjump {keyword}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;C-]&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;gC-]&lt;/code&gt;相似的命令，不用将光标放到关键字上面去, 可以使用正则表达式（前面以/开头）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;编译和使用quickfix排错&quot;&gt;编译和使用quickfix排错&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:make&lt;/code&gt;命令编译，当出现错误时会跳转到第一个错误的位置&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:cnext&lt;/code&gt;跳转到下一个错误位置，:prev跳转到第一个错误位置&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cnext&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cprev&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cfirst&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;clast&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;跳转到相应位置，cnext和cprev前面可以增加数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cnfile&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;下一个文件的第一个位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cpfile&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上一个文件的最后一个位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cc N&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;跳转到第N个位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;copen&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cclose&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;打开关闭quickfix列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cdo {cmd}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;对quicklist中的每行执行一个命令&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cfdo {cmd}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;对quicklist中的每一个文件执行一个命令&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;使用makeprg设置编译器&quot;&gt;使用makeprg设置编译器&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setlocal makeprg=NODE_DISABLE_COLORS=1\ nodelint\ %&lt;/code&gt; 这是一个js的编译器nodelint，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;:make&lt;/code&gt;命令编译，比如java,&lt;code class=&quot;highlighter-rouge&quot;&gt;setlocal makeprg=javac %&lt;/code&gt;  %代表当前文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;在项目中搜索&quot;&gt;在项目中搜索&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;grep在vim中和vim外使用的区别是，vim中会将结果写入quickfix，很方便跳转&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vim [ grep ][!] /{pattern}/ [ g ][ j ] { file } ...&lt;/code&gt; vim内部搜索引擎 vimgrep,可以使用通配符，特殊##代表参数列表的文件，可以将搜索域置空使用当前模式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;自动补全&quot;&gt;自动补全&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-n&amp;gt; &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Generic keywords&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-n&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Current buffer keywords&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-i&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;导入文件关键字，c的include，python的from import等，vim能分辨支持的语言&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-]&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;标签关键字，由ctags生成的文件中的关键字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-k&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;字典查找，最简单的方法是&lt;code class=&quot;highlighter-rouge&quot;&gt;set spell&lt;/code&gt;开启vim拼写检查&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-l&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;行补全，相比复制的优点是我们不必知道复制的内容是从哪来的,vim将会忽略所有行前的缩进&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-f&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;文件名补全，与当前路径有关&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-o&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;全方位（泛）补全 omni-completion  可以查找相关语言的&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-p&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;vim会从原始匹配的地方继续查找剩下单词，也就是说，补全多个单词&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-n&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;下一个候选词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-p&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上一个候选词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;Down&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;下一个候选词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;Up&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上一个候选词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-y&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;接受当前的单词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-e&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;退出自动补全，返回原始的单词输入处&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-h&amp;gt;&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;BS&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删除一个字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-l&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;增加一个字符安&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{char}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;停止补全并插入&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-p&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;Up&amp;gt;&lt;/code&gt;的区别是up选择时文档中的内容不变，知道我们按回车之后，而C-p文档中的内容在不断变化，我们可以接着输入其他字符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-nC-p&lt;/code&gt;两个命令连起来能保持文档中的内容不变弹出候选项，并在我们继续输入的时候实时更新候选项列表&lt;/li&gt;
  &lt;li&gt;自定义通用补全设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;:set complete-=i&lt;/code&gt;  为禁用include关键字，默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;.,w,b,u,t,i
&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;:set complete+=k&lt;/code&gt; 为打开拼写字典补全&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;拼写检查&quot;&gt;拼写检查&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:set spell&lt;/code&gt;开启检查，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;[s&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;]s&lt;/code&gt;在错误单词间移动,&lt;code class=&quot;highlighter-rouge&quot;&gt;z=&lt;/code&gt;让vim显示可能正确的单词列表，可以选择或者忽视&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setlocal spelllang=en_us&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setlocal spellfile=~ /.vim/ spell / en .utf-8.add&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setlocal spellfile+=~ /books/ practical_vim/jargon.utf-8.add&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;上面三条命令可以设置vim额外拼写检查文件，例如一些vim的专属单词&lt;/li&gt;
  &lt;li&gt;插入模式可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-s&amp;gt;&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;s&lt;/code&gt;来进行修改光标之前的错误单词&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;]s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;下一个错误单词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上一个错误单词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;z=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;为当前错误单词现实建议&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zg&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将当前单词增加到拼写文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zw&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将当前单词移除拼写文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zug&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;对于当前单词撤销zg或者zw命令&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot; 基于缩进或语法进行代码折叠
&quot;set foldmethod=indent
set foldmethod=syntax
&quot; 启动 vim 时关闭折叠代码
set nofoldenable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;操作：za，打开或关闭当前折叠；zM，关闭所有折叠；zR，打开所有折叠。&lt;/p&gt;

&lt;h4 id=&quot;一个介绍vim插件的文章强烈推荐&quot;&gt;一个介绍vim插件的文章，强烈推荐&lt;/h4&gt;
&lt;p&gt;https://github.com/yangyangwithgnu/use_vim_as_ide&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Apr 2019 10:26:00 +0800</pubDate>
        <link>http://localhost:4000/posts/vim_tool/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/vim_tool/</guid>
        
        <category>vim</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>vim模式</title>
        <description>&lt;p&gt;Vim的查找替换的匹配模式&lt;/p&gt;

&lt;h5 id=&quot;查找&quot;&gt;查找&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;:set ingorecase设置全局忽略大小写，影响配合和自动补全&lt;/li&gt;
  &lt;li&gt;\c忽略大小写，\C大小写敏感&lt;/li&gt;
  &lt;li&gt;:set smartcase在字符串全为小写时忽略大小写，字符串含有一个大写时大小写敏感&lt;/li&gt;
  &lt;li&gt;vim正则表达式更接近POSIX，而不是Perl&lt;/li&gt;
  &lt;li&gt;正则中中括号&lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;不需要转义（escape）；小括号&lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;两个都需要转义；大括号&lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;只需要转义前面的就可以了,都转义也可以。&lt;/li&gt;
  &lt;li&gt;\v very magic 可以在正则中不需要转义特殊功能字符,和Perl规则一致&lt;/li&gt;
  &lt;li&gt;\V very nomagic 除了\有特殊含义之外，其他的字符都无特殊含义，如.*等&lt;/li&gt;
  &lt;li&gt;用小括号()引住的内容会被存起来，后面可以用/n引用到，n对应小括号的出现的位置，/0代表整个匹配的内容,使用%不让小括号去捕获内容,当括号中有括号时，按左括号出现的顺序排序&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;往下查找光标下的单词（整个单词），#往上查找，g&lt;/em&gt;往下查找光标下的单词（不一定非得整个单词）,g#向上查找&lt;/li&gt;
  &lt;li&gt;escape(@u,’/'),使用escape函数将u寄存器中的内容的/前面增加\转义,更加通用的方式&lt;code class=&quot;highlighter-rouge&quot;&gt;escape(@u,getcmdtype().'\')&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;常用字符含义(:h /character-classes)&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
      &lt;th&gt;相反&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;\s&lt;/td&gt;
      &lt;td&gt;空白字符，空格和Tab&lt;/td&gt;
      &lt;td&gt;\S&lt;/td&gt;
      &lt;td&gt;非空白字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\d&lt;/td&gt;
      &lt;td&gt;数字&lt;/td&gt;
      &lt;td&gt;\D&lt;/td&gt;
      &lt;td&gt;非数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\x&lt;/td&gt;
      &lt;td&gt;十六进制 [0-9a-fA-F]&lt;/td&gt;
      &lt;td&gt;\X&lt;/td&gt;
      &lt;td&gt;非十六进制&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\o&lt;/td&gt;
      &lt;td&gt;八进制 [0-7]&lt;/td&gt;
      &lt;td&gt;\O&lt;/td&gt;
      &lt;td&gt;非八进制&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\w&lt;/td&gt;
      &lt;td&gt;数字，字母和下划线 [0-9a-zA-Z_]&lt;/td&gt;
      &lt;td&gt;\W&lt;/td&gt;
      &lt;td&gt;相反&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\h&lt;/td&gt;
      &lt;td&gt;字母和下划线[a-zA-z_]&lt;/td&gt;
      &lt;td&gt;\H&lt;/td&gt;
      &lt;td&gt;相反&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\a&lt;/td&gt;
      &lt;td&gt;字母 [a-zA-Z]&lt;/td&gt;
      &lt;td&gt;\A&lt;/td&gt;
      &lt;td&gt;相反&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\l&lt;/td&gt;
      &lt;td&gt;小写字母 [a-z]&lt;/td&gt;
      &lt;td&gt;\L&lt;/td&gt;
      &lt;td&gt;相反&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\u&lt;/td&gt;
      &lt;td&gt;大写字母 [A-Z]&lt;/td&gt;
      &lt;td&gt;\U&lt;/td&gt;
      &lt;td&gt;相反&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\e&lt;/td&gt;
      &lt;td&gt;Esc&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\t&lt;/td&gt;
      &lt;td&gt;Tab&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\r&lt;/td&gt;
      &lt;td&gt;CR&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\_&lt;/td&gt;
      &lt;td&gt;\_s 空格或者换行，s可以由上面的字母替换&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;lt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;单词的边界&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\zs \ze&lt;/td&gt;
      &lt;td&gt;匹配(match)的边界，表明了需要查找的部分,但任要符合模式(pattern)&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;/&lt;/td&gt;
      &lt;td&gt;向后查找&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;?&lt;/td&gt;
      &lt;td&gt;向前查找&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;n&lt;/td&gt;
      &lt;td&gt;重复上一次查找&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;反向上一次查找&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/CR&lt;/td&gt;
      &lt;td&gt;向下重复上一次查找&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;?CR&lt;/td&gt;
      &lt;td&gt;向上重复上一次查找&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/{content}/e&lt;/td&gt;
      &lt;td&gt;查找指定内容，并将光标放到指定内容的后面&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;//e&lt;/td&gt;
      &lt;td&gt;向下查找上一次内容并移动光标，可用于补救&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;gn&lt;/td&gt;
      &lt;td&gt;—vim7.4 进入虚拟模式选中下个匹配，一般配合operator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;gN&lt;/td&gt;
      &lt;td&gt;—vim7.4 进入虚拟模式选中上个匹配，一般配合operator&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;:set hls 设置高亮， :set nohls 关闭高亮， :nohls 这次关闭高亮&lt;/li&gt;
  &lt;li&gt;nnoremap &lt;silent&gt; &lt;C-l&gt; :&lt;C-u&gt;nohlsearch&lt;CR&gt;&lt;C-l&gt;  设置C-L清除高亮,C-L通常用来清除屏幕信息&lt;/C-l&gt;&lt;/CR&gt;&lt;/C-u&gt;&lt;/C-l&gt;&lt;/silent&gt;&lt;/li&gt;
  &lt;li&gt;:set incsearch 设置在输入搜索关键字的同时会在文档中查找，并高亮给予反馈,对于需要查找整个单词的，这时不必手动打全，只用&lt;code class=&quot;highlighter-rouge&quot;&gt;C-rC-w&lt;/code&gt;就可以将剩下的字符补全&lt;/li&gt;
  &lt;li&gt;可以先查找，捕获查找，在替换中引用，善于利用&lt;up&gt;和q/一步步完善正则表达式&lt;/up&gt;&lt;/li&gt;
  &lt;li&gt;%s///gn 统计次数，搜索域为空默认为使用当前的模式，g为每行的所有匹配，n为不实际执行替换，显示匹配的个数&lt;/li&gt;
  &lt;li&gt;:vimgrep //g %   %代表当前文件  搜索域为空代表使用当前的模式，统计次数并显示当前是第几个，cnext和cprev可以在匹配中移动就好像n和N&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;替换&quot;&gt;替换&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:[range]substitute/{pat-tern}/{string}/[flags]&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;替换域字符&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\r&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;插入回车&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\t&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;插入tab&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\\&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;代表一个反斜杠&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;插入匹配域中第一个匹配，由括号括起来为一个匹配&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\2&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;插入第二个匹配，同理，直到&lt;code class=&quot;highlighter-rouge&quot;&gt;\9&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\0&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;插入整个匹配域&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;使用上一个触发替换的字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\={Vim Script}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;使用vim脚本的结果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-r{register}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;使用寄存器里面的内容&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;flag&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;g&lt;/td&gt;
      &lt;td&gt;匹配一行的所有出现情况，作为横向（%是ex命令range,作为纵向）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;c&lt;/td&gt;
      &lt;td&gt;在替换每个内容时确认，替换，跳过，退出，替换退出，替换剩下所有退出，翻页等功能&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;替换时将搜索域留空默认使用当前匹配模式&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:let @/=string&lt;/code&gt; 相当于/string（除了在查找历史里面没用记录）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:let @a=string&lt;/code&gt; 相当于将string放入寄存器a&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s//\=@a/g&lt;/code&gt;   &lt;code class=&quot;highlighter-rouge&quot;&gt;\=&lt;/code&gt;执行vim脚本，@从寄存器中取值，这三步相当于一次替换&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;g&amp;amp;&lt;/code&gt;相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s//~/&amp;amp;&lt;/code&gt;   对所有行以同样的标识（flag）重复上次的替换，&amp;amp;上次的标识&lt;/li&gt;
  &lt;li&gt;可以对选中区域的内容实现替换&lt;/li&gt;
  &lt;li&gt;&amp;amp;相当于:s ，执行上次替换，可以使用&amp;amp;&amp;amp;保持上次的flag&lt;/li&gt;
  &lt;li&gt;可以利用子匹配(submatch)重新排序&lt;/li&gt;
  &lt;li&gt;在vim脚本中必须使用submacht()方法引用子匹配&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%s/\v(&amp;lt;dog&amp;gt;|&amp;lt;man&amp;gt;)/\={&quot;dog&quot;:&quot;man&quot;,&quot;man&quot;:&quot;dog&quot;}[submatch(1)]/g&lt;/code&gt;将dog和man单词交换（希望多年后我还能看懂）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:vimgrep //g **/*&lt;/code&gt;  查找当前目录及以下匹配模式的文件，&lt;code class=&quot;highlighter-rouge&quot;&gt;:copen&lt;/code&gt;可以浏览匹配到的文件列表(quickfix)，并且可以通过回车和分裂窗口进行切换&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:cfdo&lt;/code&gt; 对quickfix中的文件进行统一修改，之前需先设置&lt;code class=&quot;highlighter-rouge&quot;&gt;:set hidden&lt;/code&gt;不保存可以切换到其他文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 在vim中代表将命令按顺序执行，在shell中代表管道符&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;全局命令&quot;&gt;全局命令&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:[range] global[!] /{pattern}/ [cmd]&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;默认范围（range）是%,这一点与通常的命令不同，通常命令范围默认都是针对行的&lt;/li&gt;
  &lt;li&gt;模式（pattern）是查找和替换中的一致，可以留空&lt;/li&gt;
  &lt;li&gt;命令（cmd）可以是global的命令之外的任何命令,默认是print&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;global!&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;vglobal&lt;/code&gt;将作用于不匹配的模式&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;g/re/p&lt;/code&gt;是这个命令的缩写模式，也是grep命令的来源&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;v/re/d&lt;/code&gt; 仅留下匹配的行，vglobal&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;g/re/y A&lt;/code&gt;  将内容追加到寄存器a中，可以存多行内容存到寄存器中，而小写a是覆盖，多行内容只会存最后一行，可以在执行之前&lt;code class=&quot;highlighter-rouge&quot;&gt;qaq&lt;/code&gt;清空寄存器a的内容&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;g/re/t$&lt;/code&gt; 将匹配内容复制到行尾&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:sort&lt;/code&gt; 对指定范围内的行首按照字母表排序&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:g/{/ .+1,/}/-1 sort&lt;/code&gt; 这个命令里面的内容都学过，功能是?&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;g/{start}/ .,{finish}&lt;/code&gt; [cmd] 通用模式&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 24 Apr 2019 10:26:00 +0800</pubDate>
        <link>http://localhost:4000/posts/vim_pattern/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/vim_pattern/</guid>
        
        <category>vim</category>
        
        
        <category>posts</category>
        
      </item>
    
  </channel>
</rss>
