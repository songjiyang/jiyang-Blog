<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JiYang's Blog</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 03 Jul 2019 17:08:50 +0800</pubDate>
    <lastBuildDate>Wed, 03 Jul 2019 17:08:50 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>kubernetes基础概念和命令</title>
        <description>&lt;p&gt;kubernetes基础，包括kubectl命令和kubenetes的组件的概念，Pod, Node, Service等。&lt;/p&gt;

&lt;h4 id=&quot;kubectl-基本命令&quot;&gt;kubectl 基本命令&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;kubectl [command] [TYPE] [NAME] [flags]&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl create -f mysql-&amp;lt;xx&amp;gt;.yaml&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;根据yaml文件创建一个RC(ReplicationController), 或者Service, 取决于yaml文件中的kind属性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl get &amp;lt;resource&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;查看资源的大概情况,&lt;code class=&quot;highlighter-rouge&quot;&gt;-o yaml&lt;/code&gt;可以输出一个yaml格式。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl describe &amp;lt;resource&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;描述资源的详细信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl delete &amp;lt;rc或svc&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删除一个RC或者Service&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl scale rc my-web --replicas=3&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;动态调整RC副本数量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;resource可以为pods, rc, nodes, svc, deployments, endpoints(切点), rs(新版本中的RC，支持集合Label selector)等，一般单复数形式都可以&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-n&lt;/code&gt;命名空间，不写时为默认命名空间，系统命名空间为kube-system，使用可以查看一些系统的资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;kubenetes组成&quot;&gt;kubenetes组成&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Master 控制节点
    &lt;ol&gt;
      &lt;li&gt;Kubernetes API Server，提供Rest接口，所有资源增删改查的唯一入口&lt;/li&gt;
      &lt;li&gt;Kubernetes Controller Manager，资源对象的自动化控制中心&lt;/li&gt;
      &lt;li&gt;Kubernetes Scheduler，负责资源调度(Pod调度)&lt;/li&gt;
      &lt;li&gt;etcd，资源数据的保存&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Node 工作节点
    &lt;ol&gt;
      &lt;li&gt;kubelet，负责容器创建、启停，与Master沟通&lt;/li&gt;
      &lt;li&gt;kube-proxy, 实现Kubernetes Service的通信和负载均衡&lt;/li&gt;
      &lt;li&gt;Docker Engine, 负责容器创建和管理&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Pod 基本单位
    &lt;ol&gt;
      &lt;li&gt;Pause容器，代表整个Pod的状态，共享IP，Volume&lt;/li&gt;
      &lt;li&gt;用户的N个业务容器&lt;/li&gt;
      &lt;li&gt;Endpoint = Pod IP + contrainerPort，代表服务进行的对外通信地址&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Label 标签
    &lt;ol&gt;
      &lt;li&gt;用户自定义的key-value键值对，可以附加到Node, Pod, Service, RC等资源对象上面&lt;/li&gt;
      &lt;li&gt;LabelSelector可以通过=, in, not in等匹配条件来获取到特定的资源&lt;/li&gt;
      &lt;li&gt;kube-controller进程通过资源对象RC定义的Label Selector来筛选要监控的Pod副本数量&lt;/li&gt;
      &lt;li&gt;kube-proxy进行通过Service的Label Selector来选择对应的Pod，自定建议起每个Service到Pod的请求转发路由表&lt;/li&gt;
      &lt;li&gt;Node定义特定Lable，Pod的NodeSelector，kube-scheduler实现定向调度&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Deployment 部署
    &lt;ol&gt;
      &lt;li&gt;RC的一次升级，和RC相似度超过90%&lt;/li&gt;
      &lt;li&gt;相对于RC最大的升级是可以随时知道Pod部署的进度&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Horizontal Pod Autoscaler(HPA) 横向自动扩容
    &lt;ol&gt;
      &lt;li&gt;Pod横向自动扩容，通过追踪Pod的负载情况来确定是否针对调整目标Pod的副本数&lt;/li&gt;
      &lt;li&gt;通过CPUUtilizationPercetage或者应用自定义度量指标来确定是否需要扩容或者缩容&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;StatefulSet 有状态集群
    &lt;ol&gt;
      &lt;li&gt;类似Deployment,但用于有状态的集群，例如MySQL集群，MongoDB集群，Akka集群等&lt;/li&gt;
      &lt;li&gt;建立的Pod有稳定，唯一的网络标识&lt;/li&gt;
      &lt;li&gt;启停顺序是受控的&lt;/li&gt;
      &lt;li&gt;使用PV或者PVC来做数据的持久化，PV为PersistentVolum, PVC为PersistentVolumeClaim&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Service 服务
    &lt;ol&gt;
      &lt;li&gt;微服务，Pod和RC都是为了支持服务&lt;/li&gt;
      &lt;li&gt;NodeIp(每个节点物理网卡的IP地址), PodIp(虚拟的二层网络), ClusterIp(虚拟的IP,无法被ping,只能和Service Port组成一个具体的通信端口)&lt;/li&gt;
      &lt;li&gt;PodIp和ClusterIp是无法在k8s集群外访问的，要想访问，就得使用NodePort类型的Service,&lt;/li&gt;
      &lt;li&gt;NodePort在k8s的集群的每个Node建立一个访问端口，我们只要访问任意一台Node就可以访问，但还需要一个负载均衡，可以将NodePort类型改为LoadBalancer，利用公有云提供的服务来实现负载均衡。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Job 任务
    &lt;ol&gt;
      &lt;li&gt;批处理任务通常并行或者串行启动多个计算进程去处理一批工作项, 与RC, Deployment, RS类似，不过是一个特殊的Pod控制器&lt;/li&gt;
      &lt;li&gt;Job控制的Pod是短暂运行的&lt;/li&gt;
      &lt;li&gt;k8s的1.5版本后提供了CronJob&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Volume 存储卷
    &lt;ol&gt;
      &lt;li&gt;Volume是Pod中能被多个容器访问的共享目录，和Docker的Volume类似，但不能等价。&lt;/li&gt;
      &lt;li&gt;和Pod生命周期相同，和容器生命周期无关&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Persistent Volume 网络存储
    &lt;ol&gt;
      &lt;li&gt;每个Node都可以访问，独立于Pod之外，类似网盘&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Namespace 命名空间
    &lt;ol&gt;
      &lt;li&gt;实现多租户的资源隔离&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Annoation 注解
    &lt;ol&gt;
      &lt;li&gt;和Label类似，Label具有严格的命名规则，Annoation是用户定义的任意附加信息， 以便于外部工具查找&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;ConfigMap
    &lt;ol&gt;
      &lt;li&gt;集中化的配置，解决了Docker容器只能使用环境变量或者共享文件的形式将一些配置传入容器内&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 03 Jul 2019 17:53:00 +0800</pubDate>
        <link>http://localhost:4000/posts/k8s_basic/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/k8s_basic/</guid>
        
        <category>kubernetes</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>mongodb索引</title>
        <description>&lt;p&gt;mongodb的索引的基本使用&lt;/p&gt;

&lt;h2 id=&quot;索引&quot;&gt;索引&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;索引分为单键索引和复合索引&lt;/li&gt;
  &lt;li&gt;mongodb采用b-tree做索引&lt;/li&gt;
  &lt;li&gt;复合索引只能支持前缀子查询&lt;/li&gt;
  &lt;li&gt;explain()函数可以进行查询分析&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;创建索引&quot;&gt;创建索引&lt;/h4&gt;

&lt;p&gt;db.collection.createIndex(&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;keys&amp;gt;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;options&amp;gt;&lt;/code&gt;), &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;keys&amp;gt;&lt;/code&gt;文档指定了创建索引的字段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单键索引keys文档只有一个字段&lt;/li&gt;
  &lt;li&gt;复合索引keys文档有多个字段&lt;/li&gt;
  &lt;li&gt;多键索引，对一个数组字段设置索引&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;查询索引&quot;&gt;查询索引&lt;/h4&gt;

&lt;p&gt;db.collection.getIndexes()&lt;/p&gt;

&lt;h4 id=&quot;索引的效果&quot;&gt;索引的效果&lt;/h4&gt;

&lt;p&gt;db.collection.explain().&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;method(...)&amp;gt;&lt;/code&gt;,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;查看winningPlan的stage， COLLSCAN表示线性扫描，IXSCAN代表索引扫描&lt;/li&gt;
  &lt;li&gt;当查询到索引且只要返回索引字段，则不用去FETCH，最大化利用了索引&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;删除索引&quot;&gt;删除索引&lt;/h4&gt;

&lt;p&gt;db.collection.dropIndex()&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果要更改某些字段上已经创建的索引，必须首先删除原有索引，再重新创建索引，否则，新索引不会包含原有文档&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;索引的特性&quot;&gt;索引的特性&lt;/h4&gt;

&lt;h5 id=&quot;索引的唯一性&quot;&gt;索引的唯一性&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;{unique: true}&lt;/li&gt;
  &lt;li&gt;如果某个字段出现了重复值，就不可以在字段上创建唯一索引&lt;/li&gt;
  &lt;li&gt;如果新增的文档不包含唯一性索引字段，只有第一篇缺失该字段的文档可以被写入数据库，索引中该文档的键值被默认为null&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;索引的稀疏性-只将包含索引键字段的文档加入索引中&quot;&gt;索引的稀疏性 （只将包含索引键字段的文档加入索引中)&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;{sparse: true}&lt;/li&gt;
  &lt;li&gt;如果同一个索引既具有唯一性，又具有稀疏性，那么可以存储多篇缺失索引字段的文档&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;索引的生存时间-针对日期字段设定生存时间自动删除超过生存时间的文档&quot;&gt;索引的生存时间 （针对日期字段，设定生存时间，自动删除超过生存时间的文档）&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;{expireAfterSeconds: 20}&lt;/li&gt;
  &lt;li&gt;复合键索引不具备生存时间特性&lt;/li&gt;
  &lt;li&gt;当索引键是包含日期元素的数组字段时，数组中的最小日期将被用来计算文档是否已经过期&lt;/li&gt;
  &lt;li&gt;过期删除操作有一定的延迟&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 03 Jul 2019 17:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/mongodb_index/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mongodb_index/</guid>
        
        <category>mongodb</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>mongodb增删改查</title>
        <description>&lt;p&gt;mongodb的基本增删改查操作&lt;/p&gt;

&lt;h2 id=&quot;查询&quot;&gt;查询&lt;/h2&gt;

&lt;h4 id=&quot;字段操作符&quot;&gt;字段操作符&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{field : {$type : &amp;lt;BSON type&amp;gt;}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;匹配对应类型的字段的文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{field : {$exists : bool }&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;匹配对应字段存在或者不存在的文档&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;数组操作符&quot;&gt;数组操作符&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{field : {$all :[&amp;lt;value1&amp;gt;, &amp;lt;value2&amp;gt;]}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;所以value都在field数组中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{field : {$elemMatch :{&amp;lt;query1&amp;gt;, &amp;lt;query2&amp;gt;}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;数组中元素满足多个query&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;运算操作符&quot;&gt;运算操作符&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{field : {: /pattern/, : '&amp;lt;options&amp;gt;'}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;正则匹配&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{field : {: /pattern/&amp;lt;options&amp;gt;}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;正则匹配，可以和$in使用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;find方法会返回一个游标对象Cursor，可以使用索引直接获取对应位置的文档，游标会在遍历完所有的文档或者10分钟之后关闭&lt;/li&gt;
  &lt;li&gt;游标常用方法，&lt;code class=&quot;highlighter-rouge&quot;&gt;hasNext(), next(), forEach(function), limit(number), skip(offset)， count(applySkipLimit)&lt;/code&gt;, limit传入0时会返回所有文档, applySkipLimit设置为true时会考虑skip和limit来计算count,默认为false&lt;/li&gt;
  &lt;li&gt;在不提供筛选条件的时候，cursor.count()会从集合的元数据Metadata中获取结果，当数据库分布式结构比较复杂时，元数据中的文档数量可能不准确，这种情况下应该使用局和管道来计算文档数量&lt;/li&gt;
  &lt;li&gt;sort({field:1, field:-1}) 1表示从小到大排序，-1逆向&lt;/li&gt;
  &lt;li&gt;skip()命令在limit()之前执行，即时命令的顺序是相反的， sort()命令肯定在skip和limti命令之前执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;投影&quot;&gt;投影&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;{ field: 1} 1表示希望出现的字段， 0表示不希望出现，文档主键是默认出现的可以使用0来去除&lt;/li&gt;
  &lt;li&gt;不能同时使用包含和不包含，除了文档主键之外&lt;/li&gt;
  &lt;li&gt;$slide，可以对于数组使用，接收一个数字或者数组，表示这个数组对应索引的值，可以使用负数，负索引和python中功能类似&lt;/li&gt;
  &lt;li&gt;$elemMatch, 数组字段中满足筛选条件的第一个元素&lt;/li&gt;
  &lt;li&gt;$,  使用filter中的筛选条件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;更新&quot;&gt;更新&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;db.collection.update(&amp;lt;query&amp;gt;, &amp;lt;update&amp;gt;, &amp;lt;options&amp;gt;)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;update&amp;gt;&lt;/code&gt;文档不包含任何更新操作符， db.collection.update会将&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;update&amp;gt;&lt;/code&gt;文档替换数据库中的文档&lt;/li&gt;
  &lt;li&gt;主键_id是不可以更改的&lt;/li&gt;
  &lt;li&gt;如果在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;update&amp;gt;&lt;/code&gt;文档中想包含_id字段，则_id值一定要和被更新的文档_id值保持一致&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;update&amp;gt;&lt;/code&gt;替换整篇被更新文档时，只有==第一篇==符合&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;query&amp;gt;&lt;/code&gt;的文档筛选条件的文档会被更新&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;文档更新操作符&quot;&gt;文档更新操作符&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$set: { &amp;lt;field1&amp;gt;: &amp;lt;value1&amp;gt;, ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;设置一个字段的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$unset: { &amp;lt;field1&amp;gt;: &quot;&quot;, ...}} &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;设置一个字段的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$rename: { &amp;lt;field1&amp;gt;: &amp;lt;newName1&amp;gt;, ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;对字段重命名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$inc: { &amp;lt;field1&amp;gt;: &amp;lt;amonut1&amp;gt;, ...}} &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;增加或者减少&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$mul: { &amp;lt;field1&amp;gt;: &amp;lt;number1&amp;gt;, ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;相乘&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$min: { &amp;lt;field1&amp;gt;: &amp;lt;value1&amp;gt;, ...}}  &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;选择原值和新值最小的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$max: { &amp;lt;field1&amp;gt;: &amp;lt;value1&amp;gt;, ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;选择原值和新值最大的值&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;set可以更新普通字段，内嵌文档（使用.property)，数组(使用.index),可以使用index大于数据库中的长度来增加元素，跳过某些index增加元素&lt;/li&gt;
  &lt;li&gt;unset中field的值没有任何影响&lt;/li&gt;
  &lt;li&gt;unset如果字段在文档中不存在，将不会产生影响&lt;/li&gt;
  &lt;li&gt;unset对数组删除操作时，数组的长度不会被改变，而是对于位置的值被赋为null&lt;/li&gt;
  &lt;li&gt;rename的原字段不存在，将不会对文档产生影响&lt;/li&gt;
  &lt;li&gt;rename的新字段在文档中存在，则新字段原本的内容将消失，成为原字段的内容，相当于先unset再set操作&lt;/li&gt;
  &lt;li&gt;rename可以将一个字段从一个内嵌文档中取出来或者放进去，但是不可用于数组内的对象，无论是拿出来还是放进去&lt;/li&gt;
  &lt;li&gt;inc和mul只能用于number类型的&lt;/li&gt;
  &lt;li&gt;inc如果字段在文档中不存在，将会将值赋给定值，mul不存在会将值赋0&lt;/li&gt;
  &lt;li&gt;min和max可以用于其他可以比较的类型字段，如日期等&lt;/li&gt;
  &lt;li&gt;min和max的字段在文档中不存在时，和set效果相同&lt;/li&gt;
  &lt;li&gt;min和max的更新的字段类型和原字段类型不一致时，会按照BSON数据类型排序规则进行比较，Null —&amp;gt; Regular Expression&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;数组更新操作符&quot;&gt;数组更新操作符&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$addToSet: { &amp;lt;field1&amp;gt;: &amp;lt;value1&amp;gt;, ...}} &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;向数组增加一个值，如果重复，则不添加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$pop: { &amp;lt;field1&amp;gt;: &amp;lt;-1| 1&amp;gt;, ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;从头或者尾移除一个数组元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$pull: { &amp;lt;field1&amp;gt;: &amp;lt;value|condition&amp;gt;, ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;从数组字段删除特定元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$pullAll: { &amp;lt;field1&amp;gt;: [&amp;lt;value1&amp;gt;, &amp;lt;value2&amp;gt;] ...}}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;从数组字段删除特定元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{$push: {&amp;lt;field1&amp;gt;: &amp;lt;value1&amp;gt;, ...} } &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;向数组增加一个元素&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;addToSet增加内嵌文档时，内嵌文档的属性和值完全一样时才不会增加进去，顺序颠倒内嵌文档还是会被插入进数组&lt;/li&gt;
  &lt;li&gt;addToSet可以和each关键字配合将多个字段插入数组，&lt;code class=&quot;highlighter-rouge&quot;&gt;{$addToSet:{field: {$each:[value1,value2]}}}&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;{$addToSet: {field:[value1, value2]}}&lt;/code&gt;这种写法会讲一个内嵌数组插入field数组&lt;/li&gt;
  &lt;li&gt;pop 1删除结尾元素， -1删除开头元素， 可以使用在内嵌数组上面&lt;/li&gt;
  &lt;li&gt;pop删除完所有元素会留下一个空数组&lt;/li&gt;
  &lt;li&gt;pull是要删除field的元素，不用使用elemMatch，使用elemMatch表示在field类型的数组的元素进行筛选&lt;/li&gt;
  &lt;li&gt;pullAll相当于pull加in&lt;/li&gt;
  &lt;li&gt;pull和pullAll删除内嵌数组时，需要内嵌数组的顺序和值完全相同&lt;/li&gt;
  &lt;li&gt;pullAll删除内嵌文档，内嵌文档必须顺序和值完全相同， 而pull删除内嵌文档，主要内嵌文档部分匹配，顺序也可以不一致。&lt;/li&gt;
  &lt;li&gt;push和addToSet一样，如果字段不存在，这个字段会被增加到原文档中，也可以each命令配合将多个值增加到数组&lt;/li&gt;
  &lt;li&gt;push可以和each命令，position命令搭配使用从指定位置开始插入，position可以接受负数，-1表示最后一个元素的前面&lt;/li&gt;
  &lt;li&gt;push可以和each命令， sort命令搭配使用在插入新元素后并按从小到大排序，或者从大到小。在插入内嵌文档时，sort可以对内嵌文档的字段进行排序。如果只想排序的话，each的值可以设置为空数组就可以达到要求的效果&lt;/li&gt;
  &lt;li&gt;push可以和each命令，slice命令截取部分数组&lt;/li&gt;
  &lt;li&gt;postion,sort,slice命令的顺序执行顺序从大到小&lt;/li&gt;
  &lt;li&gt;set中$指定匹配条件的元素， $[]执行所有元素&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;更新文档选项&quot;&gt;更新文档选项&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;header 1&lt;/th&gt;
      &lt;th&gt;header 2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{multi: &amp;lt;boolean&amp;gt;}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;更新多个文档，默认所有更新都只针对一篇文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{upsert: &amp;lt;boolean&amp;gt; }&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;更新或者创建文档，update没有匹配到文档的时候，就会创建一篇文档&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;更新文档只能保证单个文档操作的原子性，不能保证多个文档操作的原子性&lt;/li&gt;
  &lt;li&gt;upsert的时候当匹配条件是一个精确的内容时会将匹配条件当成文档的一部分，而匹配的条件是一个模糊的内容时，如大于，小于等，就不会将匹配条件插入文档&lt;/li&gt;
  &lt;li&gt;save命令， 文档中包含_id字段时，相当于执行一个带upsert选项的update命令&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;删除&quot;&gt;删除&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;db.collection.remove({query},{option})&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;db.colletion.drop({writeConcern: &amp;lt;document&amp;gt;)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在默认情况下，remove命令会删除所有符合筛选条件的文档&lt;/li&gt;
  &lt;li&gt;如果只想删除一篇，可以使用justOne&lt;/li&gt;
  &lt;li&gt;在文档数较多时drop的效率比remove的效率高&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 26 Apr 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/mongodb_crud/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mongodb_crud/</guid>
        
        <category>mongodb</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>mongodb聚合操作</title>
        <description>&lt;p&gt;mongodb的一些聚合（aggregate）操作的基本使用&lt;/p&gt;

&lt;h2 id=&quot;聚合&quot;&gt;聚合&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{ &amp;lt;operator&amp;gt;: [&amp;lt;argument1&amp;gt;, &amp;lt;argument2&amp;gt;...]}&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;聚合操作&quot;&gt;聚合操作&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;db.collection.aggregate(&amp;lt;pipeline&amp;gt;, &amp;lt;optinos&amp;gt;)&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;字段路径表达式&quot;&gt;字段路径表达式&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;field&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;使用$来指示字段路径&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;field&amp;gt;.&amp;lt;sub-field&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;使用$和.来指示内嵌文档字段路径&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;系统变量表达式&quot;&gt;系统变量表达式&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$$&amp;lt;variable&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;使用$$来指示系统变量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;常量表达式&quot;&gt;常量表达式&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;格式&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$literal: &amp;lt;variable&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;如果variable带$开头会被当成字段路径表达式，此种写法可以有类似转义的功能&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;聚合管道阶段&quot;&gt;聚合管道阶段&lt;/h4&gt;

&lt;h5 id=&quot;project&quot;&gt;$project&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    db.acccounts.aggregate( [
        {
            $project: {
                _id: 0,    // 不输出_id
                balance: 1, // 输出balance
                clientName: &quot;$name.firstName&quot; //将name.firstName映射到clientName字段上面
            }
        }
    ])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    db.acccounts.aggregate( [
        {
            $project: {
                _id: 0,    // 不输出_id
                balance: 1, // 输出balance
                nameArray: [ &quot;$name.firstName&quot;, &quot;$name.middleName&quot;, &quot;$name.lastName&quot;] 
                //输出一个数组,取文档中的值，当文档对应字段不存在时输出null
            }
        }
    ])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;match&quot;&gt;$match&lt;/h5&gt;
&lt;p&gt;和前面的条件筛选一致&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;应该在最开始的使用match,一是剔除不关心的数据，二是提高聚合的效率&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;limit&quot;&gt;$limit&lt;/h5&gt;
&lt;h5 id=&quot;skip&quot;&gt;$skip&lt;/h5&gt;

&lt;h5 id=&quot;unwind&quot;&gt;$unwind&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    db.acccounts.aggregate( [
        {
            $unwind: {
              path: &quot;$currency&quot;,
              // 将一个数组展开
              includeArrayIndex: &quot;ccyIndex&quot;
              // 在展开时添加元素位置
            }
        }
    ])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;当unwind字段不存在，或者为null,或者为空数组的时候不会显示出来，设置preserveNullAndEmptyArrays为true的时候会将这个文档显示出来&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;sort&quot;&gt;$sort&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;1为从小到大排序，-1为从大到小排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;lookup&quot;&gt;$lookup&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;格式一
```
  $lookup: {
      from: &lt;collection to=&quot;&quot; join=&quot;&quot;&gt;,
      localFiedld: &lt;field from=&quot;&quot; the=&quot;&quot; input=&quot;&quot; documents=&quot;&quot;&gt;,
      foreignField: &amp;lt;field from the documents of the &quot;from&quot; collection&amp;gt;,
      as: &lt;output array=&quot;&quot; field=&quot;&quot;&gt;
  }&lt;/output&gt;&lt;/field&gt;&lt;/collection&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 将查询到的外汇汇率写入银行账户文档

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.accounts.aggregate([
    $lookup: {
        from: forex,   // 另一集合的名称
        localField: currency,   //本集合要匹配的字段
        foreignField: ccy,    // 另一个集合要匹配的字段
        as: forexData  //匹配上之后，forex将被当做内嵌文档插入本集合，名称则为该值
    }
]) ``` - 格式二 ```
$lookup: {
    from: &amp;lt;collection to join&amp;gt;,
    let: { &amp;lt;var_1&amp;gt;: &amp;lt;expression&amp;gt;,..., &amp;lt;var_n&amp;gt;: &amp;lt;expression&amp;gt;},
    pipeline: &amp;lt;pipeline to execute on the collection to join&amp;gt;,
    // 满足pipeline的文档才会被插入本文档
    as: &amp;lt;output array field&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; - 将特定日期外汇汇率写入余额大于100的银行账户文档
 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$lookup: {
    from: &quot;forex&quot;
    let: { bal: &quot;$balance&quot;},
    pipeline:[
    {
        $match: {
            $expr: {  //使用let中的变量的前提
                $and: [
                    {$eq: [&quot;date&quot;, new Date(&quot;2018-12-21&quot;)]},
                    {$gt: [&quot;$$bal&quot;, 100]}  //使用let中声名的变量
                ]
            }
        }
    }
    ]
    as: &quot;forexData&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
##### $group

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$group: {
    _id: &amp;lt;expression&amp;gt;,
    &amp;lt;field1&amp;gt;: { &amp;lt;accumulator1&amp;gt;: &amp;lt;expression1&amp;gt; }
} ``` - 按照交易货币来分组交易 ```
db.transaction.aggregate([
    {
        $group: {
            _id: &quot;$currency&quot;
        }
    }
]) ``` - 使用聚合操作符计算分组聚合值 ```
db.transactions.aggregate([
    {
        $group: {
            // 按照currency分组
            _id: &quot;$currency&quot;,
            // qty字段的和，赋值到新字段totalQty
            totalQty: { $sum: &quot;$qty&quot; },
            // price和qty相乘，然后求和再赋值到totalNotional
            totalNotional: {$sum: {$multiply [ &quot;$price&quot;, &quot;$qty&quot;]}},
            // price的平均值
            avgPrice: { $avg: &quot;$price&quot;}
            // 文档的数量
            count: {$sum : 1},
            // 最大金额
            maxNotional: {$max: {$multiply: [&quot;$price&quot;, &quot;$qty&quot;] }},
            // 最小金额 
            minNotional: {$min: {$multiply: [&quot;$price&quot;, &quot;$qty&quot;] }}
        }
    }
]) ``` - 如果想聚合但不分组时，可以将_id设置为null,这是所有的文档会当做一个组 - 可以和push配合创建一个新的数组 - $out可以将查询的内容写入一个新的集合，当新的集合存在时，会将文档覆盖，当管道阶段遇到错误，则新集合不会被创建，旧集合也不会被覆盖
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;聚合选项&quot;&gt;聚合选项&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;allowDiskUse: &amp;lt;boolean&amp;gt;&lt;/code&gt;, 每个聚合管道阶段使用的内存不能超过100MB,如果数据量较大，为了防止聚合管道阶段超出内存上限并且抛出错误，可以用该选项&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;聚合操作优化&quot;&gt;聚合操作优化&lt;/h4&gt;
&lt;h5 id=&quot;顺序优化&quot;&gt;顺序优化&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;$match阶段会尽量在$project阶段之前运行，但有些条件必须在project之后则不能被优化&lt;/li&gt;
  &lt;li&gt;$match阶段会在$sort阶段之前运行&lt;/li&gt;
  &lt;li&gt;$skip阶段会在$project阶段之前运行
    &lt;h5 id=&quot;合并优化&quot;&gt;合并优化&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;$sort和$limit之间没有夹杂着改变文档数量的聚合阶段，阶段可以合并，unwind和match时可以改变文档数量的操作&lt;/li&gt;
  &lt;li&gt;相同的阶段可以合并，limit, skip, match&lt;/li&gt;
  &lt;li&gt;lookup和unwind， 如果应用在lookup阶段创建的as字段上面，两则可以合并&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 26 Apr 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/mongodb_aggregate/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mongodb_aggregate/</guid>
        
        <category>mongodb</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>vim工具</title>
        <description>&lt;p&gt;Vim的一些插件和工具&lt;/p&gt;

&lt;h4 id=&quot;ctags&quot;&gt;ctags&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;c语言代码标签功能&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew install ctags&lt;/code&gt;命令安装在macos下&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ctags *.rb&lt;/code&gt;  在命令行生成标签文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:!ctags -R&lt;/code&gt; 在vim内生成标签文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:nnoremap &amp;lt;f5&amp;gt; :!ctags -R&amp;lt;CR&amp;gt; &lt;/code&gt;将生成标签文件映射为f5键&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:autocmd BufWritePost * call system(&quot;ctags -R&quot;)&lt;/code&gt; 文件保存的时候自动执行&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-]&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;跳转到代码的定义出&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-t&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;:pop&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;按照原来的标签历史返回&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gC-]&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;如果有多个定义，则会显示一个列表让你选择&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:tselect&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;拉取出可供选择的定义列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:tprev&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;:tnext&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;:tfirst&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;:tlast&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;跳转到相应的定义&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:tag {keyword}&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;:tjump {keyword}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;C-]&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;gC-]&lt;/code&gt;相似的命令，不用将光标放到关键字上面去, 可以使用正则表达式（前面以/开头）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;编译和使用quickfix排错&quot;&gt;编译和使用quickfix排错&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:make&lt;/code&gt;命令编译，当出现错误时会跳转到第一个错误的位置&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:cnext&lt;/code&gt;跳转到下一个错误位置，:prev跳转到第一个错误位置&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cnext&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cprev&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cfirst&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;clast&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;跳转到相应位置，cnext和cprev前面可以增加数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cnfile&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;下一个文件的第一个位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cpfile&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上一个文件的最后一个位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cc N&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;跳转到第N个位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;copen&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cclose&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;打开关闭quickfix列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cdo {cmd}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;对quicklist中的每行执行一个命令&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cfdo {cmd}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;对quicklist中的每一个文件执行一个命令&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;使用makeprg设置编译器&quot;&gt;使用makeprg设置编译器&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setlocal makeprg=NODE_DISABLE_COLORS=1\ nodelint\ %&lt;/code&gt; 这是一个js的编译器nodelint，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;:make&lt;/code&gt;命令编译，比如java,&lt;code class=&quot;highlighter-rouge&quot;&gt;setlocal makeprg=javac %&lt;/code&gt;  %代表当前文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;在项目中搜索&quot;&gt;在项目中搜索&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;grep在vim中和vim外使用的区别是，vim中会将结果写入quickfix，很方便跳转&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vim [ grep ][!] /{pattern}/ [ g ][ j ] { file } ...&lt;/code&gt; vim内部搜索引擎 vimgrep,可以使用通配符，特殊##代表参数列表的文件，可以将搜索域置空使用当前模式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;自动补全&quot;&gt;自动补全&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-n&amp;gt; &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Generic keywords&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-n&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Current buffer keywords&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-i&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;导入文件关键字，c的include，python的from import等，vim能分辨支持的语言&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-]&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;标签关键字，由ctags生成的文件中的关键字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-k&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;字典查找，最简单的方法是&lt;code class=&quot;highlighter-rouge&quot;&gt;set spell&lt;/code&gt;开启vim拼写检查&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-l&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;行补全，相比复制的优点是我们不必知道复制的内容是从哪来的,vim将会忽略所有行前的缩进&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-f&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;文件名补全，与当前路径有关&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-o&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;全方位（泛）补全 omni-completion  可以查找相关语言的&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-p&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;vim会从原始匹配的地方继续查找剩下单词，也就是说，补全多个单词&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-n&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;下一个候选词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-p&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上一个候选词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;Down&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;下一个候选词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;Up&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上一个候选词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-y&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;接受当前的单词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-e&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;退出自动补全，返回原始的单词输入处&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-h&amp;gt;&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;BS&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删除一个字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-l&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;增加一个字符安&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{char}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;停止补全并插入&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-p&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;Up&amp;gt;&lt;/code&gt;的区别是up选择时文档中的内容不变，知道我们按回车之后，而C-p文档中的内容在不断变化，我们可以接着输入其他字符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-nC-p&lt;/code&gt;两个命令连起来能保持文档中的内容不变弹出候选项，并在我们继续输入的时候实时更新候选项列表&lt;/li&gt;
  &lt;li&gt;自定义通用补全设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;:set complete-=i&lt;/code&gt;  为禁用include关键字，默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;.,w,b,u,t,i
&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;:set complete+=k&lt;/code&gt; 为打开拼写字典补全&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;拼写检查&quot;&gt;拼写检查&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:set spell&lt;/code&gt;开启检查，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;[s&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;]s&lt;/code&gt;在错误单词间移动,&lt;code class=&quot;highlighter-rouge&quot;&gt;z=&lt;/code&gt;让vim显示可能正确的单词列表，可以选择或者忽视&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setlocal spelllang=en_us&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setlocal spellfile=~ /.vim/ spell / en .utf-8.add&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setlocal spellfile+=~ /books/ practical_vim/jargon.utf-8.add&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;上面三条命令可以设置vim额外拼写检查文件，例如一些vim的专属单词&lt;/li&gt;
  &lt;li&gt;插入模式可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-s&amp;gt;&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-x&amp;gt;s&lt;/code&gt;来进行修改光标之前的错误单词&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;]s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;下一个错误单词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上一个错误单词&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;z=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;为当前错误单词现实建议&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zg&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将当前单词增加到拼写文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zw&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将当前单词移除拼写文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zug&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;对于当前单词撤销zg或者zw命令&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot; 基于缩进或语法进行代码折叠
&quot;set foldmethod=indent
set foldmethod=syntax
&quot; 启动 vim 时关闭折叠代码
set nofoldenable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;操作：za，打开或关闭当前折叠；zM，关闭所有折叠；zR，打开所有折叠。&lt;/p&gt;

&lt;h4 id=&quot;一个介绍vim插件的文章强烈推荐&quot;&gt;一个介绍vim插件的文章，强烈推荐&lt;/h4&gt;
&lt;p&gt;https://github.com/yangyangwithgnu/use_vim_as_ide&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Apr 2019 10:26:00 +0800</pubDate>
        <link>http://localhost:4000/posts/vim_tool/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/vim_tool/</guid>
        
        <category>vim</category>
        
        
        <category>posts</category>
        
      </item>
    
  </channel>
</rss>
