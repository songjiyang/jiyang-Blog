<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JiYang's Blog</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 02 Dec 2019 23:14:08 +0800</pubDate>
    <lastBuildDate>Mon, 02 Dec 2019 23:14:08 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>golang基本类型</title>
        <description>&lt;p&gt;golang基本类型， number, string, unicode, utf-8的基础知识&lt;/p&gt;

&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;四种类型&quot;&gt;四种类型&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;基本类型，numbers, strings, booleans&lt;/li&gt;
  &lt;li&gt;聚合类型，arrays, structs&lt;/li&gt;
  &lt;li&gt;引用类型，pointers, slices, maps, functions, channels&lt;/li&gt;
  &lt;li&gt;接口类型，interface&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;integer&quot;&gt;Integer&lt;/h1&gt;
&lt;p&gt;int8, int16, int32, int64&lt;/p&gt;

&lt;p&gt;uint8, uint16, uint32, uint64&lt;/p&gt;

&lt;p&gt;不同尺寸和有无符号的int&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;int和uint, 具体大小取决于编译器&lt;/li&gt;
  &lt;li&gt;rune, int32的同义词，很方便表示一个Unicode码点&lt;/li&gt;
  &lt;li&gt;byte, int8的同义词，重点强调是一系列的原生数据而不是一个值&lt;/li&gt;
  &lt;li&gt;uintptr, 大小不确定，但足以装下指针的值，通常用于底层编码，例如Go使用C库&lt;/li&gt;
  &lt;li&gt;int和它们的兄弟不是一种类型，需要显示转换，尽管int的底层是32位和int32一致。&lt;/li&gt;
  &lt;li&gt;数学运算符，逻辑操作符，比较操作符, 位操作符，这些和其他语言的基本相同，下面是特殊的几个
    &lt;ol&gt;
      &lt;li&gt;%, 取余操作符， 结果的符合和被除数一致， -5%3和-5%-3的结果都是-2&lt;/li&gt;
      &lt;li&gt;&amp;amp;^, 位清除操作， z = x &amp;amp;^ y   当y位1时，z位位0，否则和x的一样, 顾名思义，根据y中为1的位去清除x中的位&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;左移时空位填0，右移时空位填符号位，5右移1位是2，所以负数右移时要谨慎，-5右移1位是-3，计算机底层使用补码来存，负数的补码是对应正数的二进制按位取反再加1，正数的补码是正数的二进制&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;小知识点： &amp;amp;位操作可以用来检测某个位是不是1, 5 &amp;amp; 1 大于 0 能看出5的最右一位是1，可以通过右移5或者左移1来探测5的二进制里面有多少个1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;整型字面量可以是任何长度和类型的，（字面量的意思就是&lt;code class=&quot;highlighter-rouge&quot;&gt;a=5&lt;/code&gt;,里面的5就是字面量）0开头的是八进制，0x开头的是十六进制，八进制多用于文件权限,十六进制多强调数字的位而不是值&lt;/li&gt;
  &lt;li&gt;使用fmt.Printf的%d,%o,%x来输出十进制，八进制和十六进制&lt;/li&gt;
  &lt;li&gt;rune字面量是被单引号包起来的单个字符，可以写入ascii码&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;，也可以写入任意unicode码点例如&lt;code class=&quot;highlighter-rouge&quot;&gt;国&lt;/code&gt;, 类型是int32, 可以使用fmt.Printf的%d,%c,%q来输出十进制，字符，和引号引起来的字符&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;浮点数floating-point-numbers&quot;&gt;浮点数Floating-Point Numbers&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;float32和float64, float32提供大约6位小数精度，float64提供大约15位小数精度&lt;/li&gt;
  &lt;li&gt;特别大的数或者特别小的数应该用科学计数法&lt;/li&gt;
  &lt;li&gt;特殊数值0,-0,+Inf,-Inf,NaN, 任何和NaN的比较都是false&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;复数&quot;&gt;复数&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;complex64和complex128,&lt;/li&gt;
  &lt;li&gt;complex函数构建复数，real和imag函数去复数的实数和虚数&lt;/li&gt;
  &lt;li&gt;一个浮点字面量跟一个i就变成一个虚数字面量，例如3i,是实数为0的复数&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;布尔值&quot;&gt;布尔值&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;true和false&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;!，&amp;amp;&amp;amp;，&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;， &amp;amp;&amp;amp;的优先级高于&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;, !是单元操作符&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;逻辑布尔表达式具有短路的表现，当前面的表达式足以确定真假的时候，就不在执行后面的表达式&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;字符串&quot;&gt;字符串&lt;/h1&gt;

&lt;p&gt;字符串是不可变的一序列字节，可以包含任意数据，甚至0个字节，通常包含人类可读的文本，这些文本被解析为Utf8编码的码点（rune)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;len方法返回字符串字节的个数，而不是rune，可以通过索引访问指定位置的字节&lt;/li&gt;
  &lt;li&gt;substring操作，s[i:j]返回新字符串包含i到j(不含j)的字节，长度为j-i, i和j都可以省略，从0或者到结尾，和python的切片类似。&lt;/li&gt;
  &lt;li&gt;+操作将两个字符串进行拼接返回一个新字符串&lt;/li&gt;
  &lt;li&gt;可以使用==或者&amp;lt;进行比较，将一个字节一个字节进行比较&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;字符串的不可变性，保证了字符串的拷贝共享一份内存是安全的，所以拷贝任意长度的字符串和获取子串都是廉价的操作，它们共享着相同的内存，不会重新分配内存&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;字符串字面量&quot;&gt;字符串字面量&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;go源文件被uft8编码，所以可以在文件中直接写unicode字符&lt;/li&gt;
  &lt;li&gt;使用\来进行转义&lt;/li&gt;
  &lt;li&gt;``包裹的是原生字符串字面量，其中的内容不会被转义，适合写正则，html，json等字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unicode&quot;&gt;Unicode&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Unicode是一个收集世界上数中语言和符合的编码表，正如ASCII一样，将字符和数字进行对应起来，计算机存储数字，在需要展示给人的时候转换为字符&lt;/li&gt;
  &lt;li&gt;Unicode的每个符号对应的数字的值称为Unicode码点(Unicode code point), 在Go里面就是rune&lt;/li&gt;
  &lt;li&gt;Unicode中如果用rune（int32)来存储的话，是非常简单和正规的，这样所有字符的长度都占4个字节，然而，我们平常大多使用的字符还是2个字节就能表示的了，或者1个字节能表示的了（比如ASCII)，所有字符占4个字节会浪费很多空间，所以就出现了UTF-8编码&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;utf-8&quot;&gt;UTF-8&lt;/h2&gt;

&lt;p&gt;UTF-8是一个将Unicode码点转换为不同长度的编码，它使用1到4个字节来存储一个字符，那么这我曾经想过的一个问题是，既然一个字符的长度不同，那么在一个字节序列里面，它是如何判断边界的呢，它怎么判断这两个字节是这个字符，而这一个字节是这个字符？utf-8是这么做的，它用字节里面的高位（high-order bit)来标识下面跟着多少个字节，比如0xxxxx这样的代表着是ASCII码，下一个字节将是一个新的字符。110xxxx代表后面还跟随着两个字节，后面跟随的两个字节都是以10开头的。这样就能使用utf-8编码来节省空间。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;utf8有很多特性，使我们不用对它转为unicode也能进行获取子串，比较，从左到右读取，不必担心上下文。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Unicode&lt;/th&gt;
      &lt;th&gt;Utf-8&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;000000-00007F&lt;/td&gt;
      &lt;td&gt;0xxxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;000080-0007FF&lt;/td&gt;
      &lt;td&gt;110xxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;000800-00FFFF&lt;/td&gt;
      &lt;td&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;010000-10FFFF&lt;/td&gt;
      &lt;td&gt;11110xxx 10xxxxxx 10xxxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;许多unicode不容易写，所以go允许我们直接写数值码点，下面都是6个字节的字面量(看utf8很容易看出是6个字节，十六进制两个数是一个字节)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;世界&quot;
&quot;\xe4\xb8\x96\xe7\x95\x8c&quot;   utf8
&quot;\u4e16\u754c&quot;               16 bit unicode
&quot;\U00004e16\U0000754c&quot;       32 bit unicode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;下面都是rune字面量，256内的值可以用单个十六进制来表示，&lt;code class=&quot;highlighter-rouge&quot;&gt;\xe4\xb8\x96&lt;/code&gt;虽然是一个utf8编码的码点，但不是一个有效的rune字面量
```
‘世’, ‘\u4e16’, ‘\U00004e16’
‘\x41’&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;‘\xe4\xb8\x96’ // 不是rune字面量&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- 对于字符串直接使用索引遍历，遍历的是字节，而可用使用range来遍历rune, utf8.RuneCountInString可以返回某个字节rune的个数
- 当utf8在解码时碰到错误的字节会使用`\uFFFD`来代替，是一个�这样的符号，当碰到了这样的符号，说明其他系统传过来的字节编码可能是不清楚的
- rune和string相互转化
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;s:=”哈哈”
r:=[]rune(s)   // string =&amp;gt; rune utf8 decode
string(r)      // rune =&amp;gt; string utf8 encode
string(65)     // “A”  integer =&amp;gt; string
string(0x4eac) // “京”  0x4eac也是integer字面量
string(1234567)// � 无效&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
## 字符和字节切片

- 四个重要的标准包
    1. strings,对字符串基本的查找，替换，比较，去空，分割，结合操作
    2. bytes，对[]byte有相同的操作
    3. strconv，负责boolean, int, float等类型转换到string
    4. unicode, 对rune的各种操作
- 因为string是不可变的，所以当想通过不断累积的方式获取新的string需要不停的分配内存，使用bytes.Buffer效率更好
- 下面的方式可以将string和[]byte互转，在转化的过程中，重新分配内存和拷贝是必要的，因为[]byte是可以改变的
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;s := “abc”
b := []byte(s)
s2 := string(b)&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2 id=&quot;数字和字符串转换&quot;&gt;数字和字符串转换&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;两种将数字转换为字符串的方式，fmt.Sprintf和strconv.Itoa&lt;/li&gt;
  &lt;li&gt;strconv.FormatInt可以将数字转换为不同的进制，fmt.Sprintf的%b, %d, %u, %x也可以将数字转换为特定的进制，而且还可以加入一些额外的信息&lt;/li&gt;
  &lt;li&gt;strconv.Atoi和strconv.ParseInt可以将字符串的数字转换为数字，ParseInt可以指定进制和返回的尺寸&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;常量&quot;&gt;常量&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;在编译时期就能确定的值&lt;/li&gt;
  &lt;li&gt;常量的类型既可以显示声明，也可以根据值来进行推断&lt;/li&gt;
  &lt;li&gt;iota, 常量生成器，在常量变量自动生成自动增长的值，声明一些规律的常量很好用，比如周一到周日，KiB,MiB,GiB这些单位。iota依赖左移和右移运算符来完成某些操作，所以对于KB,MB这些值是1000的是无法用iota声明的（KiB和KB的区别，一个是1024,一个是1000，但之前学习的时候KB指的是1024， 默认KB是KiB)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;无类型常量&quot;&gt;无类型常量&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;常量是可以无类型的，无类型意思就是类型在用的时候才显式或者隐式转换，比如0这个常量，赋值给int，它就是int类型，赋值给float64, 它就是float64类型&lt;/li&gt;
  &lt;li&gt;六种无类型常量，无类型布尔，无类型整形，无类型rune, 无类型float, 无类型复数，无类型字符串&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Dec 2019 12:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/basic_type/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/basic_type/</guid>
        
        <category>golang</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>mongodb工具，安全，故障</title>
        <description>&lt;p&gt;mongodb导入和导入工具，监控工具，授权认证，故障排除&lt;/p&gt;

&lt;h3 id=&quot;安全&quot;&gt;安全&lt;/h3&gt;

&lt;h4 id=&quot;用户&quot;&gt;用户&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;创建第一个用户&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; db.createUser(
... {
... user: &quot;myUserAdmin&quot;,
... pwd: &quot;passwd&quot;,
... roles: [ &quot;userAdminAnyDatabase&quot;]
... }
... )
Successfully added user: { &quot;user&quot; : &quot;myUserAdmin&quot;, &quot;roles&quot; : [ &quot;userAdminAnyDatabase&quot; ] }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;认证&quot;&gt;认证&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在mongod启动时加入–auth参数开启登录验证&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用用户名和密码进行身份验证&lt;/p&gt;

    &lt;p&gt;mongo -u “myUserAdmin” -p “passwd” –authenticationDatabase “admin”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;authenticationDatabase表示创建用户使用的数据库，但不是指定该用户权限的。&lt;/li&gt;
  &lt;li&gt;如果目的既是登陆test数据库，而用户也是test数据库中创建，那么可以不用写后面的参数 –authenticationDatabase&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;授权&quot;&gt;授权&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;权限 = 在哪里 + 做什么&lt;/p&gt;

    &lt;p&gt;{resource:{db:”test”, collections: “”}, actions:[“find”, “update”]}&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;角色，一组权限的集合
    &lt;ol&gt;
      &lt;li&gt;read, 读取当前数据库中所有非系统集合&lt;/li&gt;
      &lt;li&gt;readWrite, 读写当前数据库中所有非系统集合&lt;/li&gt;
      &lt;li&gt;dbAdmin, 管理当前数据库&lt;/li&gt;
      &lt;li&gt;userAdmin, 管理当前数据库中的用户和角色&lt;/li&gt;
      &lt;li&gt;read/readWrite/dbAdmin/userAdminAnyDatabase 对所有数据库执行操作（只在admin数据库提供）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;创建一个只能读取test数据库的用户&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use test;
db.createUser(
    {
        user: &quot;testReader&quot;,
        pwd: &quot;passwd&quot;,
        roles: [{role: &quot;read&quot;, db: &quot;test&quot;}]
    }
)

Successfully added user: {
	&quot;user&quot; : &quot;testReader&quot;,
	&quot;roles&quot; : [
		{
			&quot;role&quot; : &quot;read&quot;,
			&quot;db&quot; : &quot;test&quot;
		}
	]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;创建一个只能读取accounts集合的用户&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use test;
db.createRole(
    {
        role: &quot;readAccount&quot;,
        privileges: [
            {
                resource: {
                    db:&quot;test&quot;, 
                    collection: &quot;accounts&quot;
                },
                actions: [&quot;find&quot;]
            }
        ],
        roles: []
    }
)
use test;
db.createUser(
    {
        user: &quot;accountsReader&quot;,
        pwd: &quot;passwd&quot;,
        roles: [&quot;readAccount&quot;]
    }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;roles字段可以从已有角色中继承权限&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;工具&quot;&gt;工具&lt;/h2&gt;

&lt;h4 id=&quot;数据导入导出&quot;&gt;数据导入导出&lt;/h4&gt;
&lt;h5 id=&quot;mongoexport&quot;&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongoexport/&quot;&gt;mongoexport&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&quot;mongoimport&quot;&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongoimport/index.html&quot;&gt;mongoimport&lt;/a&gt;&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;upsertFileds 根据特定字段去对比从而选择去更新还是插入&lt;/li&gt;
  &lt;li&gt;stopOnError 发送错误停止&lt;/li&gt;
  &lt;li&gt;maintainInsertionOrder 维持csv的顺序导入&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;监控&quot;&gt;监控&lt;/h4&gt;

&lt;h5 id=&quot;mongostat统计mongodb数据库当前的状态&quot;&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongostat/index.html&quot;&gt;mongostat&lt;/a&gt;，统计mongodb数据库当前的状态&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;需要用户有clusterMonitor的角色&lt;/li&gt;
  &lt;li&gt;可以指定打印间隔和次数&lt;/li&gt;
  &lt;li&gt;o指定需要查看的指标
    &lt;ol&gt;
      &lt;li&gt;commman - 每秒执行的命令数&lt;/li&gt;
      &lt;li&gt;dirty, used - 数据库引擎缓存的使用量百分比&lt;/li&gt;
      &lt;li&gt;vsize - 虚拟内存使用量（MB)&lt;/li&gt;
      &lt;li&gt;res - 常驻内存使用量&lt;/li&gt;
      &lt;li&gt;conn - 连接数&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;mongotop显示每个集合上的读写时间&quot;&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongotop/index.html&quot;&gt;mongotop&lt;/a&gt;,显示每个集合上的读写时间&lt;/h5&gt;

&lt;h2 id=&quot;故障&quot;&gt;故障&lt;/h2&gt;

&lt;h5 id=&quot;响应时间过长&quot;&gt;响应时间过长&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;合适的索引，使用explain()查看索引的有效性&lt;/li&gt;
  &lt;li&gt;工作集超出RAM的大小，使用mongostat查看服务的状态，used百分比远远大过dirty的百分比时，表示mongo内存不够使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;连接失败&quot;&gt;连接失败&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;默认情况下，mongod进程可以支持多达65536个连接，不恰当的&lt;strong&gt;配置&lt;/strong&gt;可能限制连接数
    &lt;ol&gt;
      &lt;li&gt;db.serverStatus().connections可查看连接数&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;ulimt -a配置中间的open files也会限制mongodb的连接数&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Sep 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/mongodb_tool_security/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mongodb_tool_security/</guid>
        
        <category>mongodb</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>mongodb技巧</title>
        <description>&lt;p&gt;mongodb的一些技巧&lt;/p&gt;

&lt;h2 id=&quot;按日期分组&quot;&gt;按日期分组&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;要分组的日期是Date类型的&lt;/li&gt;
  &lt;li&gt;注意timezone, +0800代表中国时区&lt;/li&gt;
  &lt;li&gt;group的_id可以进行转字符串，然后连接处理&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.suggestions.aggregate([
    {
        $project: {
          year: {$year: {date:'$submitDate', timezone:'+0800'}},
          month: {$month: {date:'$submitDate', timezone:'+0800'}},
          dayOfMonth: {$dayOfMonth: {date:'$submitDate', timezone:'+0800'}},
          submitDate:1
        }
    },
    {
        $group: {
            _id:{year:'$year', month:'$month', day:'$dayOfMonth'},
            
            count: {
                $sum: 1
            }
        }
    },
    {   
        $sort : { _id : 1 }
    }   
])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;要分组的日期是timeStamp，并且为string, 网上查找的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection('wechat_message').aggregate(  
    [     
        {   $project : { day : {$substr: [&quot;$sendTime&quot;, 0, 10] }}},          
        {   $group   : { _id : &quot;$day&quot;,  number : { $sum : 1 }}},  
        {   $sort    : { _id : -1 }}          
    ]  
)  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 05 Sep 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/mongodb_skill/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mongodb_skill/</guid>
        
        <category>mongodb</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>kubernetes基础使用</title>
        <description>&lt;p&gt;kubernetes基础使用，创建一个Deployment,创建一个Service&lt;/p&gt;

&lt;h3 id=&quot;使用k8s部署一个nginx&quot;&gt;使用k8s部署一个nginx&lt;/h3&gt;

&lt;h4 id=&quot;创建一个deployment&quot;&gt;创建一个Deployment&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;controllers/nginx-deployment.yaml&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-deployment&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;必需字段&quot;&gt;必需字段&lt;/h5&gt;
&lt;p&gt;在想要创建的 Kubernetes 对象对应的 .yaml 文件中，需要配置如下的字段：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;apiVersion - 创建该对象所使用的 Kubernetes API 的版本&lt;/li&gt;
  &lt;li&gt;kind - 想要创建的对象的类型&lt;/li&gt;
  &lt;li&gt;metadata - 帮助识别对象唯一性的数据，包括一个 name 字符串、UID 和可选的 namespace&lt;/li&gt;
  &lt;li&gt;spec 字段。对象 spec 的精确格式对每个 Kubernetes 对象来说是不同的，包含了特定于该对象的嵌套字段。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#&quot;&gt;Kubernetes API&lt;/a&gt;参考能够帮助我们找到任何我们想创建的对象的 spec 格式。&lt;/p&gt;

&lt;h4 id=&quot;问题&quot;&gt;问题&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Deployment的matchLabels必选能选到template的label,否则创建资源的时候会报错。==为什么==, 因为这个Deployment选择不到对应的pod，达不到要求的replica为3，所以会不停新建template的Pod。&lt;/li&gt;
  &lt;li&gt;现在如何访问这个nginx
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl port-forward &amp;lt;podname&amp;gt; 80:80&lt;/code&gt;，使用kubectl代理，这样只有拥有k8s集群权限才行，用不了k8s也访问不到&lt;/li&gt;
      &lt;li&gt;建一个Service，下面介绍&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;创建一个service&quot;&gt;创建一个Service&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;service/nginx-service.yml&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;http&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;targetPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;nodePort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;31100&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;NodePort&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;spec.type分别有ClusterIP(default), NodePort, and LoadBalancer，
    &lt;ol&gt;
      &lt;li&gt;默认的ClusterIP会给这个Service生成一个虚拟IP,在k8s集群中，我们可以通过这个ip,或者Service的name(借助的k8s的dns解析)来访问这个服务，但我们还是无法在外部访问到这个服务&lt;/li&gt;
      &lt;li&gt;NodePort会在k8s集群中的所有Node开启一个nodePort指定的端口或者随机端口，然后我们可以拿k8s集群中任意一个机器的IP加这个nodePort就可以访问这个服务，但这个任然不是最佳的方式，因为我们需要一个额外的文件来维护不同服务的不同端口，在后面可以借助ingress，和ingress controller边缘路由器来暴露端口，并对k8s内部的服务进行反向代理。&lt;/li&gt;
      &lt;li&gt;LoadBalancer借助云服务商提供的LoadBalancer软件，将服务暴露在云服务商的LB软件上，每个厂商的配置不太相同&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 03 Sep 2019 17:53:00 +0800</pubDate>
        <link>http://localhost:4000/posts/k8s_basic_use/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/k8s_basic_use/</guid>
        
        <category>kubernetes</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>kubernetes基础概念和命令</title>
        <description>&lt;p&gt;kubernetes基础，包括kubectl命令和kubenetes的组件的概念，Pod, Node, Service等。&lt;/p&gt;

&lt;h4 id=&quot;概念&quot;&gt;概念&lt;/h4&gt;

&lt;p&gt;    Kubernetes最初源于谷歌内部的Borg，提供了面向应用的容器集群部署和管理系统。Kubernetes的目标旨在消除编排物理/虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的workflows 和更高级的自动化任务。 Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。 Kubernetes 还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。&lt;/p&gt;

&lt;h4 id=&quot;kubenetes组成&quot;&gt;kubenetes组成&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://pvuj0n458.bkt.clouddn.com/youdao/kubernetes-high-level-component-archtecture.jpg&quot; alt=&quot;kubernetes-high-level-component-architectur&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Master 控制节点
    &lt;ol&gt;
      &lt;li&gt;Kubernetes API Server，提供Rest接口，所有资源增删改查的唯一入口&lt;/li&gt;
      &lt;li&gt;Kubernetes Controller Manager，资源对象的自动化控制中心&lt;/li&gt;
      &lt;li&gt;Kubernetes Scheduler，负责资源调度(Pod调度)&lt;/li&gt;
      &lt;li&gt;etcd，资源数据的保存&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Node 工作节点
    &lt;ol&gt;
      &lt;li&gt;kubelet，负责容器创建、启停，与Master沟通&lt;/li&gt;
      &lt;li&gt;kube-proxy, 实现Kubernetes Service的通信和负载均衡&lt;/li&gt;
      &lt;li&gt;Docker Engine, 负责容器创建和管理&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Pod 基本单位
    &lt;ol&gt;
      &lt;li&gt;Pause容器，代表整个Pod的状态，共享IP，Volume&lt;/li&gt;
      &lt;li&gt;用户的N个业务容器&lt;/li&gt;
      &lt;li&gt;Endpoint = Pod IP + contrainerPort，代表服务进行的对外通信地址&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Label 标签
    &lt;ol&gt;
      &lt;li&gt;用户自定义的key-value键值对，可以附加到Node, Pod, Service, RC等资源对象上面&lt;/li&gt;
      &lt;li&gt;LabelSelector可以通过=, in, not in等匹配条件来获取到特定的资源&lt;/li&gt;
      &lt;li&gt;kube-controller进程通过资源对象RC定义的Label Selector来筛选要监控的Pod副本数量&lt;/li&gt;
      &lt;li&gt;kube-proxy进行通过Service的Label Selector来选择对应的Pod，自定建议起每个Service到Pod的请求转发路由表&lt;/li&gt;
      &lt;li&gt;Node定义特定Lable，Pod的NodeSelector，kube-scheduler实现定向调度&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Deployment 部署
    &lt;ol&gt;
      &lt;li&gt;RC的一次升级，和RC相似度超过90%&lt;/li&gt;
      &lt;li&gt;相对于RC最大的升级是可以随时知道Pod部署的进度&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Horizontal Pod Autoscaler(HPA) 横向自动扩容
    &lt;ol&gt;
      &lt;li&gt;Pod横向自动扩容，通过追踪Pod的负载情况来确定是否针对调整目标Pod的副本数&lt;/li&gt;
      &lt;li&gt;通过CPUUtilizationPercetage或者应用自定义度量指标来确定是否需要扩容或者缩容&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;StatefulSet 有状态集群
    &lt;ol&gt;
      &lt;li&gt;类似Deployment,但用于有状态的集群，例如MySQL集群，MongoDB集群，Akka集群等&lt;/li&gt;
      &lt;li&gt;建立的Pod有稳定，唯一的网络标识&lt;/li&gt;
      &lt;li&gt;启停顺序是受控的&lt;/li&gt;
      &lt;li&gt;使用PV或者PVC来做数据的持久化，PV为PersistentVolum, PVC为PersistentVolumeClaim&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Service 服务
    &lt;ol&gt;
      &lt;li&gt;微服务，Pod和RC都是为了支持服务&lt;/li&gt;
      &lt;li&gt;NodeIp(每个节点物理网卡的IP地址), PodIp(虚拟的二层网络), ClusterIp(虚拟的IP,无法被ping,只能和Service Port组成一个具体的通信端口)&lt;/li&gt;
      &lt;li&gt;PodIp和ClusterIp是无法在k8s集群外访问的，要想访问，就得使用NodePort类型的Service,&lt;/li&gt;
      &lt;li&gt;NodePort在k8s的集群的每个Node建立一个访问端口，我们只要访问任意一台Node就可以访问，但还需要一个负载均衡，可以将NodePort类型改为LoadBalancer，利用公有云提供的服务来实现负载均衡。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Job 任务
    &lt;ol&gt;
      &lt;li&gt;批处理任务通常并行或者串行启动多个计算进程去处理一批工作项, 与RC, Deployment, RS类似，不过是一个特殊的Pod控制器&lt;/li&gt;
      &lt;li&gt;Job控制的Pod是短暂运行的&lt;/li&gt;
      &lt;li&gt;k8s的1.5版本后提供了CronJob&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Volume 存储卷
    &lt;ol&gt;
      &lt;li&gt;Volume是Pod中能被多个容器访问的共享目录，和Docker的Volume类似，但不能等价。&lt;/li&gt;
      &lt;li&gt;和Pod生命周期相同，和容器生命周期无关&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Persistent Volume 网络存储
    &lt;ol&gt;
      &lt;li&gt;每个Node都可以访问，独立于Pod之外，类似网盘&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Namespace 命名空间
    &lt;ol&gt;
      &lt;li&gt;实现多租户的资源隔离&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Annoation 注解
    &lt;ol&gt;
      &lt;li&gt;和Label类似，Label具有严格的命名规则，Annoation是用户定义的任意附加信息， 以便于外部工具查找&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;ConfigMap
    &lt;ol&gt;
      &lt;li&gt;集中化的配置，解决了Docker容器只能使用环境变量或者共享文件的形式将一些配置传入容器内&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;kubectl-基本命令&quot;&gt;kubectl 基本命令&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;kubectl [command] [TYPE] [NAME] [flags]&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl create -f mysql-&amp;lt;xx&amp;gt;.yaml&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;根据yaml文件创建一个RC(ReplicationController), 或者Service, 取决于yaml文件中的kind属性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl get &amp;lt;resource&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;查看资源的大概情况,&lt;code class=&quot;highlighter-rouge&quot;&gt;-o yaml&lt;/code&gt;可以输出一个yaml格式。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl describe &amp;lt;resource&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;描述资源的详细信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl delete &amp;lt;rc或svc&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删除一个RC或者Service&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl scale rc my-web --replicas=3&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;动态调整RC副本数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl logs &amp;lt;podname&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;查看某个pod的日志&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;resource可以为pods, rc, nodes, svc, deployments, endpoints(切点), rs(新版本中的RC，支持集合Label selector)等，一般单复数形式都可以&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-n&lt;/code&gt;命名空间，不写时为默认命名空间，系统命名空间为kube-system，使用可以查看一些系统的资源&lt;/li&gt;
  &lt;li&gt;更多参数参考官方文档&lt;a href=&quot;https://kubernetes.io/docs/reference/kubectl/overview/&quot;&gt;kubectl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://jimmysong.io/kubernetes-handbook/concepts/&quot;&gt;《kubernetes-handbook》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Sep 2019 17:53:00 +0800</pubDate>
        <link>http://localhost:4000/posts/k8s_basic/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/k8s_basic/</guid>
        
        <category>kubernetes</category>
        
        
        <category>posts</category>
        
      </item>
    
  </channel>
</rss>
